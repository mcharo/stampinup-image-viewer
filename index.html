<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stampin' Up Image Viewer</title>
    <script src="potrace.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        :root {
            --primary-color: #2563eb;
            --border-radius: 8px;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background-color: #f8fafc;
            color: #1e293b;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        h1 {
            font-size: 2rem;
            font-weight: 600;
            margin: 0;
            color: #0f172a;
        }

        .input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
            background: white;
            padding: 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
        }

        input[type="number"] {
            padding: 0.75rem 1rem;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            font-size: 1rem;
            width: 200px;
            transition: border-color 0.15s ease;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        button {
            padding: 0.75rem 1.5rem;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        button:hover {
            background-color: #1d4ed8;
        }

        .image-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            width: 100%;
        }

        .image-wrapper {
            background: white;
            padding: 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .image-wrapper img {
            max-width: 100%;
            height: auto;
            border-radius: calc(var(--border-radius) - 2px);
        }

        .controls {
            display: flex;
            gap: 1rem;
            padding-top: 0.5rem;
            border-top: 1px solid #e2e8f0;
            align-items: center;
            flex-direction: column;
        }

        .color-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            justify-content: space-between;
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.75rem;
            background: #f8fafc;
            border-radius: var(--border-radius);
            width: 100%;
            justify-content: center;
            border: 1px solid #e2e8f0;
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        /* Responsive color palette for individual object cards */
        .svg-object-card .color-palette {
            gap: 0.25rem;
            padding: 0.5rem;
            justify-content: flex-start;
        }

        .svg-object-card .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        /* Responsive control layout for individual object cards */
        .svg-object-card .color-control {
            flex-direction: column;
            gap: 0.5rem;
            align-items: stretch;
        }

        .svg-object-card .color-inputs {
            justify-content: center;
        }

        .svg-object-card .palette-selector {
            min-width: 100px;
        }

        .svg-object-card .hex-input {
            width: 80px;
        }

        .svg-object-card .color-picker {
            width: 40px;
            height: 35px;
        }

        .color-swatch:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .color-swatch.active {
            outline: 3px solid var(--primary-color);
            outline-offset: 2px;
            transform: scale(1.1);
        }

        .palette-selector {
            padding: 0.5rem 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            font-size: 0.875rem;
            background: white;
            cursor: pointer;
            min-width: 120px;
        }

        .palette-selector:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .color-inputs {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .color-picker {
            width: 50px;
            height: 40px;
            padding: 0;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            cursor: pointer;
        }

        .hex-input {
            width: 90px;
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            font-family: monospace;
            font-size: 0.875rem;
        }

        .hex-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .error {
            color: #dc2626;
            font-size: 0.875rem;
            padding: 0.75rem 1rem;
            background-color: #fef2f2;
            border: 1px solid #fee2e2;
            border-radius: var(--border-radius);
            display: none;
        }

        .error:not(:empty) {
            display: block;
        }

        .svg-container {
            margin: 0;
            border: 1px solid #e2e8f0;
            padding: 0;
            width: 100%;
            aspect-ratio: 1;
            overflow: hidden;
            position: relative;
            background: #fff;
            border-radius: calc(var(--border-radius) - 2px);
        }

        .svg-container svg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .svg-objects-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .svg-object-card {
            background: white;
            padding: 1rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            border: 2px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .svg-object-card.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .svg-object-preview {
            width: 100%;
            height: 150px;
            border: 1px solid #e2e8f0;
            border-radius: calc(var(--border-radius) - 2px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fff;
            overflow: hidden;
        }

        .svg-object-preview svg {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        .object-controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .object-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            color: #374151;
        }

        .object-actions {
            display: flex;
            gap: 0.5rem;
        }

        .object-actions button {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .remove-object {
            background-color: #dc2626;
        }

        .remove-object:hover {
            background-color: #b91c1c;
        }

        /* Full-image download button row */
        .download-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .download-row button {
            flex: 1;
            padding: 0.5rem 0.9rem;
            font-size: 0.875rem;
            white-space: nowrap;
        }

        /* Compact action toolbar for object cards */
        .object-action-row {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            flex-wrap: wrap;
        }

        .object-action-row button {
            padding: 0.35rem 0.7rem;
            font-size: 0.75rem;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            line-height: 1.5;
        }

        .action-divider {
            width: 1px;
            height: 18px;
            background: #d1d5db;
            margin: 0 0.125rem;
            flex-shrink: 0;
        }

        .cricut-group {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .cricut-group input[type="number"] {
            width: 38px;
            padding: 0.35rem 0.25rem;
            font-size: 0.75rem;
            text-align: center;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
        }

        .remove-object-compact {
            background: none;
            color: #9ca3af;
            padding: 0.2rem 0.4rem;
            font-size: 1rem;
            line-height: 1;
            border-radius: 4px;
            font-weight: 400;
        }

        .remove-object-compact:hover {
            color: #dc2626;
            background: #fef2f2;
        }

        .svg-container path {
            cursor: pointer;
            transition: opacity 0.15s ease;
        }

        .svg-container path:hover {
            opacity: 0.7;
        }

        .svg-container path.selected {
            stroke: var(--primary-color);
            stroke-width: 2;
            stroke-dasharray: 5,5;
        }

        .objects-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .break-off-hint {
            font-size: 0.875rem;
            color: #6b7280;
            text-align: center;
            padding: 0.75rem;
            background: #f9fafb;
            border-radius: var(--border-radius);
            border: 1px dashed #d1d5db;
        }

        .object-detection-controls {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            padding: 1rem;
            margin: 1rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-group label {
            font-size: 0.875rem;
            color: #374151;
            min-width: 120px;
        }

        .range-input {
            width: 150px;
        }

        .range-value {
            font-family: monospace;
            font-size: 0.875rem;
            color: #6b7280;
            min-width: 40px;
        }

        .detect-button {
            background-color: #059669;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .detect-button:hover {
            background-color: #047857;
        }

        .detect-button:disabled {
            background-color: #9ca3af !important;
            cursor: not-allowed !important;
            opacity: 0.7;
        }

        .detect-button:disabled:hover {
            background-color: #9ca3af !important;
        }

        .object-overlay {
            position: absolute;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.15s ease;
            border-radius: 4px;
        }

        .object-overlay:hover {
            border-color: var(--primary-color);
            background-color: rgba(37, 99, 235, 0.1);
        }

        .object-overlay.detected {
            border-color: #10b981;
            background-color: rgba(16, 185, 129, 0.1);
        }

        .object-count-info {
            font-size: 0.875rem;
            color: #059669;
            font-weight: 500;
            text-align: center;
        }

        .detection-toggle {
            background: none;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            justify-content: space-between;
            transition: all 0.15s ease;
            font-weight: 500;
        }

        .detection-toggle:hover {
            background-color: #f9fafb;
            border-color: #d1d5db;
        }

        .detection-toggle-icon {
            transition: transform 0.15s ease;
            font-size: 0.75rem;
            color: #6b7280;
        }

        .detection-toggle.expanded .detection-toggle-icon {
            transform: rotate(180deg);
        }

        .detection-params {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            max-height: 0;
            opacity: 0;
        }

        .detection-params.expanded {
            max-height: 200px;
            opacity: 1;
            padding-top: 1rem;
        }

        /* Better responsive styling for object card color palettes */
        .svg-object-card .color-palette {
            justify-content: center !important;
            padding: 0.6rem !important;
            gap: 0.3rem !important;
            margin: 0 auto !important;
            max-width: 100% !important;
        }

        .svg-object-card .color-swatch {
            width: 22px !important;
            height: 22px !important;
        }

        /* Keep color controls on same line in object cards */
        .svg-object-card .color-control {
            flex-direction: row !important;
            align-items: center !important;
            justify-content: space-between !important;
        }

        .svg-object-card .palette-selector {
            flex: 1 !important;
            margin-left: 0.5rem !important;
        }

        /* Add spacing between color controls and palette */
        .svg-object-card .color-control {
            margin-bottom: 0.75rem !important;
        }

        /* Prevent palette from touching card edges */
        .svg-object-card .color-palette {
            margin-left: 0.5rem !important;
            margin-right: 0.5rem !important;
            max-width: calc(100% - 1rem) !important;
            width: auto !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Stampin' Up Image Viewer</h1>
        <div class="input-group">
            <input type="number" id="productId" placeholder="Enter product ID" min="1" value="165346">
            <button onclick="loadImages()">Load Images</button>
        </div>
        <div id="stampSetInfo" style="padding: 0.25rem 1.5rem; font-size: 0.875rem; color: #6b7280; min-height: 1.5em;"></div>
        <div id="error" class="error"></div>
        <div class="image-container" id="imageContainer"></div>
    </div>

    <script>
        const baseUrl = 'https://res.cloudinary.com/stampin-up/image/upload/prod/images/default-source/product-image';
        let detectedStampSetName = '';

        function findBannerRegion(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Analyze the left 60%, top 50% of the image where packaging appears
            const scanW = Math.floor(img.naturalWidth * 0.6);
            const scanH = Math.floor(img.naturalHeight * 0.5);
            canvas.width = scanW;
            canvas.height = scanH;
            ctx.drawImage(img, 0, 0, scanW, scanH, 0, 0, scanW, scanH);

            const imageData = ctx.getImageData(0, 0, scanW, scanH);
            const pixels = imageData.data;
            const DARK = 50;

            function lum(i) {
                return pixels[i] * 0.299 + pixels[i + 1] * 0.587 + pixels[i + 2] * 0.114;
            }

            // Per-row: fraction of pixels darker than threshold
            const rowDark = new Float32Array(scanH);
            for (let y = 0; y < scanH; y++) {
                let n = 0;
                for (let x = 0; x < scanW; x++) {
                    if (lum((y * scanW + x) * 4) < DARK) n++;
                }
                rowDark[y] = n / scanW;
            }

            // Collect contiguous dark-row bands (>= 25% dark pixels per row)
            const ROW_TH = 0.25;
            const rawBands = [];
            let start = null;
            for (let y = 0; y < scanH; y++) {
                if (rowDark[y] >= ROW_TH) {
                    if (start === null) start = y;
                } else if (start !== null) {
                    rawBands.push({ y0: start, y1: y });
                    start = null;
                }
            }
            if (start !== null) rawBands.push({ y0: start, y1: scanH });
            if (rawBands.length === 0) return null;

            // Merge bands separated by small gaps (handles white text box inside banner)
            const MERGE_GAP = Math.floor(scanH * 0.06);
            const merged = [{ ...rawBands[0] }];
            for (let i = 1; i < rawBands.length; i++) {
                const prev = merged[merged.length - 1];
                if (rawBands[i].y0 - prev.y1 <= MERGE_GAP) {
                    prev.y1 = rawBands[i].y1;
                } else {
                    merged.push({ ...rawBands[i] });
                }
            }

            // Pick the tallest band that meets minimum height
            const MIN_H = Math.max(20, scanH * 0.05);
            const tallest = merged
                .filter(b => (b.y1 - b.y0) >= MIN_H)
                .sort((a, b) => (b.y1 - b.y0) - (a.y1 - a.y0))[0];
            if (!tallest) return null;

            // Find horizontal extent: first and last columns with >= 20% dark pixels in the band
            const bandH = tallest.y1 - tallest.y0;
            const COL_TH = 0.2;
            let x0 = 0, x1 = scanW;

            for (let x = 0; x < scanW; x++) {
                let n = 0;
                for (let y = tallest.y0; y < tallest.y1; y++) {
                    if (lum((y * scanW + x) * 4) < DARK) n++;
                }
                if (n / bandH >= COL_TH) { x0 = x; break; }
            }
            for (let x = scanW - 1; x >= 0; x--) {
                let n = 0;
                for (let y = tallest.y0; y < tallest.y1; y++) {
                    if (lum((y * scanW + x) * 4) < DARK) n++;
                }
                if (n / bandH >= COL_TH) { x1 = x + 1; break; }
            }

            // Small padding so text at edges isn't clipped
            const padY = Math.max(2, Math.floor(bandH * 0.05));
            const padX = Math.max(2, Math.floor((x1 - x0) * 0.02));
            return {
                x0: Math.max(0, x0 - padX),
                y0: Math.max(0, tallest.y0 - padY),
                x1: Math.min(img.naturalWidth, x1 + padX),
                y1: Math.min(img.naturalHeight, tallest.y1 + padY)
            };
        }

        function extractOCRLines(data) {
            if (data.lines && data.lines.length > 0) return data.lines;
            const lines = [];
            for (const block of (data.blocks || [])) {
                for (const para of (block.paragraphs || [])) {
                    for (const line of (para.lines || [])) {
                        lines.push(line);
                    }
                }
            }
            return lines;
        }

        function cleanOCRText(text) {
            return text.replace(/[|[\]{}]/g, '').replace(/\s+/g, ' ').trim();
        }

        async function detectStampSetName(imageBlob) {
            const infoDiv = document.getElementById('stampSetInfo');
            infoDiv.textContent = 'Detecting stamp set name...';
            detectedStampSetName = '';

            try {
                const img = new Image();
                img.src = URL.createObjectURL(imageBlob);
                await new Promise(resolve => { img.onload = resolve; });

                // Step 1: Find the black banner region via pixel analysis
                const region = findBannerRegion(img);
                if (!region) {
                    URL.revokeObjectURL(img.src);
                    infoDiv.textContent = '';
                    return;
                }

                // Step 2: Crop to just the banner
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const rw = region.x1 - region.x0;
                const rh = region.y1 - region.y0;
                canvas.width = rw;
                canvas.height = rh;
                ctx.drawImage(img, region.x0, region.y0, rw, rh, 0, 0, rw, rh);

                // Step 3: Invert colors (white text on black â†’ black text on white for OCR)
                const imageData = ctx.getImageData(0, 0, rw, rh);
                const px = imageData.data;
                for (let i = 0; i < px.length; i += 4) {
                    px[i] = 255 - px[i];
                    px[i + 1] = 255 - px[i + 1];
                    px[i + 2] = 255 - px[i + 2];
                }
                ctx.putImageData(imageData, 0, 0);
                URL.revokeObjectURL(img.src);

                // Step 4: OCR just the banner
                const worker = await Tesseract.createWorker('eng');
                const result = await worker.recognize(canvas);
                await worker.terminate();

                // Step 5: Find the stamp set name using anchor-based approach
                const anchorPatterns = [/photopolymer/i, /stamp\s*set/i, /cling/i, /clear.?mount/i, /wood.?mount/i];
                const ocrLines = extractOCRLines(result.data);

                const anchorLines = [];
                const candidateLines = [];
                for (const line of ocrLines) {
                    const text = cleanOCRText(line.text);
                    if (text.length < 2) continue;
                    if (anchorPatterns.some(p => p.test(text))) {
                        anchorLines.push(line);
                    } else {
                        candidateLines.push(line);
                    }
                }

                if (anchorLines.length > 0 && candidateLines.length > 0) {
                    let bestCandidate = null;
                    let bestDistance = Infinity;
                    for (const candidate of candidateLines) {
                        const cy = (candidate.bbox.y0 + candidate.bbox.y1) / 2;
                        for (const anchor of anchorLines) {
                            const ay = (anchor.bbox.y0 + anchor.bbox.y1) / 2;
                            const dist = Math.abs(cy - ay);
                            if (dist < bestDistance) {
                                bestDistance = dist;
                                bestCandidate = candidate;
                            }
                        }
                    }
                    if (bestCandidate) {
                        detectedStampSetName = cleanOCRText(bestCandidate.text);
                        infoDiv.textContent = `Stamp set: ${detectedStampSetName}`;
                        return;
                    }
                }

                // Fallback: filter out anchor text and take the first remaining line
                const textLines = result.data.text
                    .split('\n')
                    .map(l => cleanOCRText(l))
                    .filter(l => l.length > 1)
                    .filter(l => !anchorPatterns.some(p => p.test(l)));

                if (textLines.length > 0) {
                    detectedStampSetName = textLines[0];
                    infoDiv.textContent = `Stamp set: ${detectedStampSetName}`;
                } else {
                    infoDiv.textContent = '';
                }
            } catch (err) {
                console.error('OCR detection failed:', err);
                infoDiv.textContent = '';
            }
        }

        // Add event listener for Enter key
        document.getElementById('productId').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                loadImages();
            }
        });

        // Load images automatically on page load
        // Pre-populate product ID from ?id= query parameter if present
        window.onload = function() {
            const params = new URLSearchParams(window.location.search);
            const idParam = params.get('id');
            if (idParam) {
                document.getElementById('productId').value = idParam;
            }
            loadImages();
        };

        async function loadImages() {
            const productId = document.getElementById('productId').value;
            const errorDiv = document.getElementById('error');
            const imageContainer = document.getElementById('imageContainer');
            detectedStampSetName = '';
            document.getElementById('stampSetInfo').textContent = '';
            
            if (!productId) {
                errorDiv.textContent = 'Please enter a product ID';
                return;
            }

            errorDiv.textContent = '';
            imageContainer.innerHTML = '';

            const imageUrls = [
                `${baseUrl}/${productId}.jpg`,
                `${baseUrl}/${productId}o01.jpg`
            ];

            for (const url of imageUrls) {
                try {
                    const response = await fetch(url);
                    if (response.ok) {
                        const blob = await response.blob();
                        
                        const imageWrapper = document.createElement('div');
                        imageWrapper.className = 'image-wrapper';
                        
                        if (url.includes('o01')) {
                            // Create a temporary image to get dimensions
                            const tempImg = document.createElement('img');
                            tempImg.src = URL.createObjectURL(blob);
                            
                            // Wait for image to load
                            await new Promise(resolve => {
                                tempImg.onload = resolve;
                            });
                            
                            const originalWidth = tempImg.naturalWidth;
                            const originalHeight = tempImg.naturalHeight;
                            
                            const isBW = await isBlackAndWhite(tempImg);
                            if (isBW) {
                                // Convert to SVG automatically
                                const svg = await convertToSVG(tempImg, originalWidth, originalHeight);
                                const svgContainer = document.createElement('div');
                                svgContainer.className = 'svg-container';
                                
                                // Scale the SVG for display
                                const displayScale = Math.min(280 / originalWidth, 280 / originalHeight);
                                const scaledSvg = svg.replace(/<svg([^>]*)>/, (match, attributes) => {
                                    return `<svg${attributes} viewBox="0 0 ${originalWidth} ${originalHeight}" width="100%" height="100%">`;
                                });
                                
                                svgContainer.innerHTML = scaledSvg;
                                imageWrapper.appendChild(svgContainer);
                                
                                // Add object detection controls
                                const detectionControls = createObjectDetectionControls(tempImg, svgContainer, originalWidth, originalHeight, productId);
                                imageWrapper.appendChild(detectionControls);

                                // Add main image controls (before objects container)
                                const mainControlsHeader = document.createElement('h3');
                                mainControlsHeader.textContent = 'Full Image Controls';
                                mainControlsHeader.style.fontSize = '1rem';
                                mainControlsHeader.style.fontWeight = '600';
                                mainControlsHeader.style.color = '#374151';
                                mainControlsHeader.style.margin = '1.5rem 0 0.5rem 0';
                                imageWrapper.appendChild(mainControlsHeader);

                                const controls = document.createElement('div');
                                controls.className = 'controls';
                                
                                const colorControl = document.createElement('div');
                                colorControl.className = 'color-control';
                                
                                // Create color inputs container
                                const colorInputs = document.createElement('div');
                                colorInputs.className = 'color-inputs';
                                
                                const colorPicker = document.createElement('input');
                                colorPicker.type = 'color';
                                colorPicker.className = 'color-picker';
                                colorPicker.value = '#000000';
                                
                                const hexInput = document.createElement('input');
                                hexInput.type = 'text';
                                hexInput.className = 'hex-input';
                                hexInput.value = '#000000';
                                hexInput.placeholder = '#000000';

                                // Add palette selector
                                const paletteSelector = document.createElement('select');
                                paletteSelector.className = 'palette-selector';
                                
                                // Add color palettes
                                const colorPalettes = {
                                    "2025-2027 In Colors": {
                                        "Strawberry Slush": "#f26b73",
                                        "Timid Tiger": "#f68e4f",
                                        "Darling Duckling": "#f0d34f",
                                        "Cloud Cover": "#b4c5c0",
                                        "Secret Sea": "#334249"
                                    },
                                    "2024-2026 In Colors": {
                                        "Pretty in Pink": "#f8abb6",
                                        "Peach Pie": "#fab474",
                                        "Shy Shamrock": "#49bc8f",
                                        "Summer Splash": "#63c4b1",
                                        "Petunia Pop": "#d37eb4"
                                    },
                                    "Basics": {
                                        "Basic Beige": "#e3dbc5",
                                        "Very Vanilla": "#fff7e1",
                                        "Basic White": "#ffffff",
                                        "White Willow": "#ffffff",
                                        "Basic Black": "#000000",
                                        "Bronze & Ivory": "#a97448",
                                        "Crumb Cake": "#c8ad8c"
                                    },
                                    "Subtles": {
                                        "Petal Pink": "#fcd1bb",
                                        "Calypso Coral": "#f47e63",
                                        "Lemon Lolly": "#fff8a2",
                                        "Soft Sea Foam": "#e6f1d2",
                                        "Lost Lagoon": "#7baaa1",
                                        "Pool Party": "#a9dbd6",
                                        "Balmy Blue": "#a0d6ea",
                                        "Highland Heather": "#ad95c6",
                                        "Fresh Freesia": "#e6b7d6",
                                        "Bubble Bath": "#fad5e6"
                                    },
                                    "Brights": {
                                        "Poppy Parade": "#ed193a",
                                        "Melon Mambo": "#e94d87",
                                        "Flirty Flamingo": "#f5928b",
                                        "Pumpkin Pie": "#f89433",
                                        "Daffodil Delight": "#ffdc67",
                                        "Lemon Lime Twist": "#dee568",
                                        "Granny Apple Green": "#a3c149",
                                        "Coastal Cabana": "#90d2be",
                                        "Azure Afternoon": "#27a0d6",
                                        "Berry Burst": "#b74985"
                                    },
                                    "Regals": {
                                        "Cherry Cobbler": "#a10637",
                                        "Real Red": "#c52342",
                                        "Cajun Craze": "#c0492d",
                                        "Crushed Curry": "#f8bd16",
                                        "Old Olive": "#98a04d",
                                        "Garden Green": "#4d8b56",
                                        "Shaded Spruce": "#00815b",
                                        "Pretty Peacock": "#006f71",
                                        "Blueberry Bushel": "#0d5993",
                                        "Gorgeous Grape": "#855da4"
                                    },
                                    "Neutrals": {
                                        "Mossy Meadow": "#656739",
                                        "Misty Moonlight": "#58728e",
                                        "Night of Navy": "#213e6d",
                                        "Blackberry Bliss": "#582752",
                                        "Early Espresso": "#63412c",
                                        "Pecan Pie": "#a97448",
                                        "Crumb Cake": "#c8ad8c",
                                        "Gray Granite": "#b3aba1",
                                        "Smoky Slate": "#bdbdbe",
                                        "Basic Gray": "#767e85"
                                    }
                                };

                                // Add options to palette selector
                                Object.keys(colorPalettes).forEach(paletteName => {
                                    const option = document.createElement('option');
                                    option.value = paletteName;
                                    option.textContent = paletteName;
                                    paletteSelector.appendChild(option);
                                });

                                // Create color palette container
                                const colorPalette = document.createElement('div');
                                colorPalette.className = 'color-palette';

                                // Function to update color palette
                                function updateColorPalette(paletteName) {
                                    colorPalette.innerHTML = '';
                                    const colors = colorPalettes[paletteName];
                                    
                                    Object.entries(colors).forEach(([name, hex]) => {
                                        const swatch = document.createElement('div');
                                        swatch.className = 'color-swatch';
                                        swatch.style.backgroundColor = hex;
                                        swatch.title = name;
                                        
                                        swatch.addEventListener('click', () => {
                                            // Remove active class from all swatches
                                            colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                                            // Add active class to clicked swatch
                                            swatch.classList.add('active');
                                            
                                            // Update color picker and hex input
                                            colorPicker.value = hex;
                                            hexInput.value = hex;
                                            tintSVG(svgContainer.querySelector('svg'), hex);
                                        });
                                        
                                        colorPalette.appendChild(swatch);
                                    });
                                }

                                // Initial palette update
                                updateColorPalette(paletteSelector.value);

                                // Update palette when selection changes
                                paletteSelector.addEventListener('change', (e) => {
                                    updateColorPalette(e.target.value);
                                });
                                
                                // Sync color picker and hex input
                                colorPicker.addEventListener('input', (e) => {
                                    const color = e.target.value;
                                    hexInput.value = color;
                                    tintSVG(svgContainer.querySelector('svg'), color);
                                    // Remove active class from all swatches
                                    colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                                });
                                
                                hexInput.addEventListener('input', (e) => {
                                    let color = e.target.value;
                                    // Add # if missing
                                    if (color.charAt(0) !== '#') {
                                        color = '#' + color;
                                    }
                                    // Validate hex color
                                    if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                                        colorPicker.value = color;
                                        tintSVG(svgContainer.querySelector('svg'), color);
                                        // Remove active class from all swatches
                                        colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                                    }
                                });
                                
                                // Assemble the structure
                                colorInputs.appendChild(colorPicker);
                                colorInputs.appendChild(hexInput);
                                
                                colorControl.appendChild(colorInputs);
                                colorControl.appendChild(paletteSelector);
                                
                                const dlIcon = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" style="display:inline-block;vertical-align:-1px;margin-right:5px"><path d="M6 1v7M3.5 5.5L6 8l2.5-2.5M2 10.5h8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';

                                const downloadButton = document.createElement('button');
                                downloadButton.innerHTML = dlIcon + 'SVG';
                                downloadButton.onclick = () => downloadSVG(svgContainer.querySelector('svg'), productId, originalWidth, originalHeight);

                                const downloadPngButton = document.createElement('button');
                                downloadPngButton.innerHTML = dlIcon + 'PNG';
                                downloadPngButton.onclick = () => downloadPNG(svgContainer.querySelector('svg'), productId, originalWidth, originalHeight);

                                const downloadJpgButton = document.createElement('button');
                                downloadJpgButton.innerHTML = dlIcon + 'JPG';
                                downloadJpgButton.onclick = () => downloadJPG(svgContainer.querySelector('svg'), productId, originalWidth, originalHeight);

                                const downloadRow = document.createElement('div');
                                downloadRow.className = 'download-row';
                                downloadRow.appendChild(downloadButton);
                                downloadRow.appendChild(downloadPngButton);
                                downloadRow.appendChild(downloadJpgButton);

                                controls.appendChild(colorControl);
                                controls.appendChild(colorPalette);
                                controls.appendChild(downloadRow);

                                imageWrapper.appendChild(controls);

                                // Create container for individual objects
                                const objectsHeader = document.createElement('h3');
                                objectsHeader.textContent = 'Individual Objects';
                                objectsHeader.style.fontSize = '1rem';
                                objectsHeader.style.fontWeight = '600';
                                objectsHeader.style.color = '#374151';
                                objectsHeader.style.margin = '1.5rem 0 0.5rem 0';
                                objectsHeader.id = `objectsHeader-${productId}`;
                                objectsHeader.style.display = 'none'; // Initially hidden
                                imageWrapper.appendChild(objectsHeader);

                                const objectsContainer = document.createElement('div');
                                objectsContainer.className = 'objects-container';
                                objectsContainer.id = `objects-${productId}`;
                                imageWrapper.appendChild(objectsContainer);
                            } else {
                                // If not black and white, show original image
                                const img = document.createElement('img');
                                img.src = URL.createObjectURL(blob);
                                img.alt = `Product ${productId}`;
                                imageWrapper.appendChild(img);
                            }
                            
                            // Clean up the temporary URL
                            URL.revokeObjectURL(tempImg.src);
                        } else {
                            // For regular images, just show them
                            const img = document.createElement('img');
                            img.src = URL.createObjectURL(blob);
                            img.alt = `Product ${productId}`;
                            imageWrapper.appendChild(img);

                            // Kick off OCR detection in the background for the product photo
                            detectStampSetName(blob);
                        }

                        imageContainer.appendChild(imageWrapper);
                    }
                } catch (error) {
                    console.error(`Error loading image ${url}:`, error);
                }
            }

            if (imageContainer.children.length === 0) {
                errorDiv.textContent = 'No images found for this product ID';
            }
        }

        function blobToDataUrl(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function adjustImageHue(img, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            for (let i = 0; i < data.length; i += 4) {
                if (data[i] < 250 || data[i + 1] < 250 || data[i + 2] < 250) {
                    data[i] = r;
                    data[i + 1] = g;
                    data[i + 2] = b;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            img.src = canvas.toDataURL();
        }

        async function isBlackAndWhite(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let blackPixels = 0;
            let whitePixels = 0;
            let totalPixels = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Check if pixel is black (all channels close to 0)
                if (r < 50 && g < 50 && b < 50) {
                    blackPixels++;
                }
                // Check if pixel is white (all channels close to 255)
                else if (r > 200 && g > 200 && b > 200) {
                    whitePixels++;
                }
                totalPixels++;
            }
            
            const blackPercentage = (blackPixels / totalPixels) * 100;
            const whitePercentage = (whitePixels / totalPixels) * 100;
            
            // Consider it black and white if more than 90% of pixels are either black or white
            return (blackPercentage + whitePercentage) > 90;
        }

        async function convertToSVG(img, originalWidth, originalHeight) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = originalWidth;
                canvas.height = originalHeight;
                
                ctx.drawImage(img, 0, 0);
                
                // Convert to black and white
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const gray = (r + g + b) / 3;
                    const threshold = 128;
                    
                    data[i] = data[i + 1] = data[i + 2] = gray < threshold ? 0 : 255;
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // Get the image data as a data URL
                const dataUrl = canvas.toDataURL('image/png');
                
                // Set Potrace parameters
                Potrace.setParameter({
                    turdsize: 25, // Minimum area of a path
                    alphamax: 0.8, // Maximum angle for a corner
                    optcurve: true, // Optimize curves
                    opttolerance: 0.2, // Curve optimization tolerance
                    threshold: 128 // Black/white threshold
                });
                
                // Load the image and process it
                Potrace.loadImageFromUrl(dataUrl);
                
                // Process the image and get SVG
                Potrace.process(function() {
                    // Get SVG at original size
                    const svg = Potrace.getSVG(1); // Use scale of 1 for original size
                    resolve(svg);
                });
            });
        }

        function tintSVG(svg, color) {
            if (!svg) return;
            
            // Get the path element
            const path = svg.querySelector('path');
            if (!path) return;
            
            // Update the fill color
            path.setAttribute('fill', color);
        }

        function createObjectDetectionControls(originalImage, svgContainer, originalWidth, originalHeight, productId) {
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'object-detection-controls';
            
            // Create toggle button for parameters
            const toggleButton = document.createElement('button');
            toggleButton.className = 'detection-toggle';
            toggleButton.innerHTML = `
                <span>Detection Parameters</span>
                <span class="detection-toggle-icon">â–¼</span>
            `;
            
            // Create collapsible parameters container
            const paramsContainer = document.createElement('div');
            paramsContainer.className = 'detection-params';
            
            // Create controls
            const controlRow1 = document.createElement('div');
            controlRow1.className = 'control-row';
            
            // Minimum object size control
            const minSizeGroup = document.createElement('div');
            minSizeGroup.className = 'control-group';
            
            const minSizeLabel = document.createElement('label');
            minSizeLabel.textContent = 'Min Object Size:';
            
            const minSizeInput = document.createElement('input');
            minSizeInput.type = 'range';
            minSizeInput.className = 'range-input';
            minSizeInput.min = '100';
            minSizeInput.max = '5000';
            minSizeInput.value = '500';
            minSizeInput.id = `minSize-${productId}`;
            
            const minSizeValue = document.createElement('span');
            minSizeValue.className = 'range-value';
            minSizeValue.textContent = minSizeInput.value;
            
            minSizeInput.addEventListener('input', () => {
                minSizeValue.textContent = minSizeInput.value;
            });
            
            minSizeGroup.appendChild(minSizeLabel);
            minSizeGroup.appendChild(minSizeInput);
            minSizeGroup.appendChild(minSizeValue);
            
            // Gap tolerance control
            const gapGroup = document.createElement('div');
            gapGroup.className = 'control-group';
            
            const gapLabel = document.createElement('label');
            gapLabel.textContent = 'Gap Tolerance:';
            
            const gapInput = document.createElement('input');
            gapInput.type = 'range';
            gapInput.className = 'range-input';
            gapInput.min = '1';
            gapInput.max = '40';
            gapInput.value = '20';
            gapInput.id = `gapTolerance-${productId}`;
            
            const gapValue = document.createElement('span');
            gapValue.className = 'range-value';
            gapValue.textContent = gapInput.value;
            
            gapInput.addEventListener('input', () => {
                gapValue.textContent = gapInput.value;
            });
            
            gapGroup.appendChild(gapLabel);
            gapGroup.appendChild(gapInput);
            gapGroup.appendChild(gapValue);
            
            controlRow1.appendChild(minSizeGroup);
            controlRow1.appendChild(gapGroup);
            
            // Add controls to parameters container
            paramsContainer.appendChild(controlRow1);
            
            // Create buttons container
            const buttonsContainer = document.createElement('div');
            buttonsContainer.style.display = 'flex';
            buttonsContainer.style.gap = '0.5rem';
            buttonsContainer.style.marginTop = '0.5rem';
            buttonsContainer.style.flexWrap = 'wrap';
            
            // Refresh objects button (initially hidden)
            const refreshButton = document.createElement('button');
            refreshButton.className = 'detect-button';
            refreshButton.textContent = 'Refresh Objects';
            refreshButton.style.display = 'none';
            refreshButton.id = `refreshButton-${productId}`;
            refreshButton.onclick = () => detectAndShowObjects(originalImage, svgContainer, originalWidth, originalHeight, productId);
            
            // Show/Hide borders toggle
            const toggleBordersButton = document.createElement('button');
            toggleBordersButton.className = 'detect-button';
            toggleBordersButton.textContent = 'Hide Borders';
            toggleBordersButton.style.backgroundColor = '#6b7280';
            toggleBordersButton.style.display = 'none'; // Initially hidden until objects are detected
            toggleBordersButton.id = `toggleBorders-${productId}`;
            toggleBordersButton.onclick = () => toggleObjectBorders(svgContainer, toggleBordersButton);
            
            buttonsContainer.appendChild(refreshButton);
            buttonsContainer.appendChild(toggleBordersButton);
            
            // Track parameter changes
            let lastMinSize = minSizeInput.value;
            let lastGapTolerance = gapInput.value;
            
            function checkParameterChanges() {
                const currentMinSize = minSizeInput.value;
                const currentGapTolerance = gapInput.value;
                
                if (currentMinSize !== lastMinSize || currentGapTolerance !== lastGapTolerance) {
                    refreshButton.style.display = 'inline-block';
                } else {
                    refreshButton.style.display = 'none';
                }
            }
            
            function updateLastParameters() {
                lastMinSize = minSizeInput.value;
                lastGapTolerance = gapInput.value;
                refreshButton.style.display = 'none';
            }
            
            // Update parameter change listeners
            minSizeInput.addEventListener('input', () => {
                minSizeValue.textContent = minSizeInput.value;
                checkParameterChanges();
            });
            
            gapInput.addEventListener('input', () => {
                gapValue.textContent = gapInput.value;
                checkParameterChanges();
            });
            
            // Store functions for external access
            svgContainer.updateLastParameters = updateLastParameters;
            svgContainer.showToggleBorders = () => {
                toggleBordersButton.style.display = 'inline-block';
            };
            
            
            // Toggle functionality
            toggleButton.addEventListener('click', () => {
                const isExpanded = paramsContainer.classList.contains('expanded');
                
                if (isExpanded) {
                    paramsContainer.classList.remove('expanded');
                    toggleButton.classList.remove('expanded');
                } else {
                    paramsContainer.classList.add('expanded');
                    toggleButton.classList.add('expanded');
                }
            });
            
            // Info area
            const infoDiv = document.createElement('div');
            infoDiv.className = 'object-count-info';
            infoDiv.id = `objectInfo-${productId}`;
            infoDiv.textContent = 'Auto-detecting objects in the image...';
            
            // Info about processing time
            const infoText = document.createElement('div');
            infoText.className = 'detection-warning';
            infoText.innerHTML = 'â„¹ï¸ <strong>Auto-Detection:</strong> Objects are automatically detected when the image is converted. Processing typically takes 10-30 seconds in the background.';
            infoText.style.fontSize = '0.8rem';
            infoText.style.color = '#374151';
            infoText.style.textAlign = 'center';
            infoText.style.padding = '0.5rem';
            infoText.style.backgroundColor = '#f0f9ff';
            infoText.style.border = '1px solid #bae6fd';
            infoText.style.borderRadius = 'var(--border-radius)';
            infoText.style.marginTop = '0.5rem';
            
            // Assemble the structure
            controlsDiv.appendChild(toggleButton);
            controlsDiv.appendChild(paramsContainer);
            controlsDiv.appendChild(buttonsContainer);
            controlsDiv.appendChild(infoDiv);
            controlsDiv.appendChild(infoText);
            
            // Auto-start object detection
            setTimeout(() => {
                detectAndShowObjects(originalImage, svgContainer, originalWidth, originalHeight, productId);
            }, 500);
            
            return controlsDiv;
        }

        function detectAndShowObjects(originalImage, svgContainer, originalWidth, originalHeight, productId) {
            // Clear any existing overlays
            const existingOverlays = svgContainer.querySelectorAll('.object-overlay');
            existingOverlays.forEach(overlay => overlay.remove());
            
            // Get UI elements - use the refresh button instead of old detect button
            const refreshButton = document.getElementById(`refreshButton-${productId}`);
            const toggleBordersButton = document.getElementById(`toggleBorders-${productId}`);
            const infoDiv = document.getElementById(`objectInfo-${productId}`);
            
            // Set loading state
            if (refreshButton) {
                refreshButton.textContent = 'Detecting...';
                refreshButton.disabled = true;
                refreshButton.style.backgroundColor = '#9ca3af';
                refreshButton.style.cursor = 'not-allowed';
            }
            
            if (infoDiv) {
                infoDiv.textContent = 'Analyzing image for objects...';
                infoDiv.style.color = '#059669';
            }
            
            // Get parameters
            const minSize = parseInt(document.getElementById(`minSize-${productId}`).value);
            const gapTolerance = parseInt(document.getElementById(`gapTolerance-${productId}`).value);
            
            // Start async processing (no setTimeout needed since we're chunking)
            findConnectedComponents(originalImage, minSize, gapTolerance)
                .then(objects => {
                    // Update info
                    if (objects.length > 0) {
                        infoDiv.textContent = `Found ${objects.length} objects. Click on any highlighted area to extract it.`;
                        infoDiv.style.color = '#059669';
                        
                        // Show the toggle borders button when objects are found
                        if (toggleBordersButton) {
                            toggleBordersButton.style.display = 'inline-block';
                        }
                    } else {
                        infoDiv.textContent = 'No objects found. Try adjusting the parameters.';
                        infoDiv.style.color = '#dc2626';
                        
                        // Hide the toggle borders button when no objects
                        if (toggleBordersButton) {
                            toggleBordersButton.style.display = 'none';
                        }
                    }
                    
                    // Create clickable overlays for each object
                    objects.forEach((obj, index) => {
                        const overlay = document.createElement('div');
                        overlay.className = 'object-overlay detected';
                        
                        // Store object data for resize updates
                        overlay.dataset.objectBounds = JSON.stringify(obj.bounds);
                        overlay.dataset.originalWidth = originalWidth;
                        overlay.dataset.originalHeight = originalHeight;
                        overlay.dataset.objectIndex = index;
                        
                        // Calculate initial position
                        updateOverlayPosition(overlay, svgContainer);
                        
                        overlay.title = `Object ${index + 1} (${obj.pixelCount} pixels)`;
                        
                        overlay.addEventListener('click', (e) => {
                            e.stopPropagation();
                            extractObject(obj, originalImage, originalWidth, originalHeight, productId, index + 1);
                            overlay.style.display = 'none';
                        });
                        
                        svgContainer.appendChild(overlay);
                    });
                    
                    // Add resize listener for this container if not already added
                    if (!svgContainer.dataset.resizeListenerAdded) {
                        svgContainer.dataset.resizeListenerAdded = 'true';
                        
                        const resizeObserver = new ResizeObserver(() => {
                            updateAllOverlayPositions(svgContainer);
                        });
                        resizeObserver.observe(svgContainer);
                        
                        // Also listen for window resize as a backup
                        window.addEventListener('resize', () => {
                            setTimeout(() => updateAllOverlayPositions(svgContainer), 50);
                        });
                    }
                    
                    // Update parameter tracking to hide refresh button
                    if (svgContainer.updateLastParameters) {
                        svgContainer.updateLastParameters();
                    }
                    
                    // Sync toggle borders button state - after refresh, borders are visible so button should say "Hide Borders"
                    if (toggleBordersButton && objects.length > 0) {
                        toggleBordersButton.textContent = 'Hide Borders';
                    }
                })
                .catch(error => {
                    console.error('Error during object detection:', error);
                    infoDiv.textContent = 'Error occurred during object detection. Please try again.';
                    infoDiv.style.color = '#dc2626';
                })
                .finally(() => {
                    // Restore button state
                    if (refreshButton) {
                        refreshButton.textContent = 'Refresh Objects';
                        refreshButton.disabled = false;
                        refreshButton.style.backgroundColor = '#059669';
                        refreshButton.style.cursor = 'pointer';
                    }
                });
        }

        function updateOverlayPosition(overlay, svgContainer) {
            const bounds = JSON.parse(overlay.dataset.objectBounds);
            const originalWidth = parseInt(overlay.dataset.originalWidth);
            const originalHeight = parseInt(overlay.dataset.originalHeight);
            
            // Calculate position relative to current SVG container size
            const containerRect = svgContainer.getBoundingClientRect();
            const scaleX = containerRect.width / originalWidth;
            const scaleY = containerRect.height / originalHeight;
            
            overlay.style.left = `${bounds.left * scaleX}px`;
            overlay.style.top = `${bounds.top * scaleY}px`;
            overlay.style.width = `${bounds.width * scaleX}px`;
            overlay.style.height = `${bounds.height * scaleY}px`;
        }

        function updateAllOverlayPositions(svgContainer) {
            const overlays = svgContainer.querySelectorAll('.object-overlay.detected');
            overlays.forEach(overlay => {
                if (overlay.style.display !== 'none') {
                    updateOverlayPosition(overlay, svgContainer);
                }
            });
        }

        function toggleObjectBorders(svgContainer, toggleButton) {
            const overlays = svgContainer.querySelectorAll('.object-overlay.detected');
            const isCurrentlyVisible = overlays.length > 0 && overlays[0].style.visibility !== 'hidden';
            
            overlays.forEach(overlay => {
                if (isCurrentlyVisible) {
                    overlay.style.visibility = 'hidden';
                    toggleButton.textContent = 'Show Borders';
                } else {
                    overlay.style.visibility = 'visible';
                    toggleButton.textContent = 'Hide Borders';
                }
            });
        }

        function findConnectedComponents(image, minSize, gapTolerance) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = image.naturalWidth;
                canvas.height = image.naturalHeight;
                ctx.drawImage(image, 0, 0);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;
                
                // Convert to binary array (true for black pixels) - optimized with larger chunks and Uint8Array
                const binary = new Uint8Array(width * height);
                
                // Process binary conversion in larger chunks for better performance
                let binaryIndex = 0;
                function processBinaryChunk() {
                    const chunkSize = 50000; // Increased from 10k to 50k pixels per chunk
                    const endIndex = Math.min(binaryIndex + chunkSize, data.length);
                    
                    // Optimized binary conversion with bitwise operations
                    for (let i = binaryIndex; i < endIndex; i += 4) {
                        const gray = (data[i] + data[i + 1] + data[i + 2]) * 0.333; // Faster than division
                        binary[i >> 2] = gray < 128 ? 1 : 0; // Bitwise shift instead of division
                    }
                    
                    binaryIndex = endIndex;
                    
                    if (binaryIndex < data.length) {
                        requestAnimationFrame(processBinaryChunk);
                    } else {
                        processMorphology();
                    }
                }
                
                function processMorphology() {
                    if (gapTolerance <= 1) {
                        findComponents();
                        return;
                    }
                    
                    let iter = 0;
                    function dilateIteration() {
                        if (iter >= gapTolerance) {
                            findComponents();
                            return;
                        }
                        
                        // Use in-place dilation with temp array for better memory efficiency
                        const temp = new Uint8Array(width * height);
                        let processed = 0;
                        const chunkSize = 5000; // Increased from 1k to 5k pixels per chunk
                        
                        function processDilateChunk() {
                            const endRow = Math.min(processed + chunkSize, height - 1);
                            
                            for (let y = Math.max(processed, 1); y < endRow; y++) {
                                const rowOffset = y * width;
                                for (let x = 1; x < width - 1; x++) {
                                    const idx = rowOffset + x;
                                    if (!binary[idx]) {
                                        // Optimized neighbor check - unrolled loop for speed
                                        if (binary[idx - width - 1] || binary[idx - width] || binary[idx - width + 1] ||
                                            binary[idx - 1] || binary[idx + 1] ||
                                            binary[idx + width - 1] || binary[idx + width] || binary[idx + width + 1]) {
                                            temp[idx] = 1;
                                        }
                                    } else {
                                        temp[idx] = 1;
                                    }
                                }
                            }
                            
                            processed = endRow;
                            
                            if (processed < height - 1) {
                                requestAnimationFrame(processDilateChunk);
                            } else {
                                binary.set(temp); // Fast array copy
                                iter++;
                                requestAnimationFrame(dilateIteration);
                            }
                        }
                        
                        processDilateChunk();
                    }
                    
                    dilateIteration();
                }
                
                function findComponents() {
                    const visited = new Uint8Array(width * height);
                    const components = [];
                    let currentY = 0;
                    
                    function processComponentChunk() {
                        const chunkSize = 200; // Increased from 50 to 200 rows per chunk
                        const endY = Math.min(currentY + chunkSize, height);
                        
                        for (let y = currentY; y < endY; y++) {
                            const rowOffset = y * width;
                            for (let x = 0; x < width; x++) {
                                const idx = rowOffset + x;
                                if (binary[idx] && !visited[idx]) {
                                    const component = floodFillOptimized(x, y, binary, visited, width, height);
                                    if (component.pixelCount >= minSize) {
                                        // Calculate final bounds
                                        component.bounds.width = component.bounds.right - component.bounds.left + 1;
                                        component.bounds.height = component.bounds.bottom - component.bounds.top + 1;
                                        
                                        // Use exact flood-fill pixels â€” avoids picking up
                                        // ink from neighbouring objects sharing the bounding box
                                        component.getPixels = () => component.pixelIndices.map(
                                            idx => ({ x: idx % width, y: (idx / width) | 0 })
                                        );
                                        
                                        components.push(component);
                                    }
                                }
                            }
                        }
                        
                        currentY = endY;
                        
                        if (currentY < height) {
                            requestAnimationFrame(processComponentChunk);
                        } else {
                            resolve(components);
                        }
                    }
                    
                    processComponentChunk();
                }
                
                processBinaryChunk();
            });
        }

        function floodFillOptimized(startX, startY, binary, visited, width, height) {
            // Use array for stack instead of pushing objects for better performance
            const stack = new Array(width * height * 2); // Pre-allocate maximum possible size
            let stackTop = 0;
            stack[stackTop++] = startX;
            stack[stackTop++] = startY;

            const component = {
                pixelCount: 0,
                bounds: { left: startX, top: startY, right: startX, bottom: startY },
                pixelIndices: [] // exact pixels belonging to this component
            };

            while (stackTop > 0) {
                const y = stack[--stackTop];
                const x = stack[--stackTop];
                const idx = y * width + x;

                if (x < 0 || x >= width || y < 0 || y >= height || visited[idx] || !binary[idx]) {
                    continue;
                }

                visited[idx] = 1;
                component.pixelCount++;
                component.pixelIndices.push(idx);

                // Update bounds with bitwise operations for slight performance gain
                if (x < component.bounds.left) component.bounds.left = x;
                if (x > component.bounds.right) component.bounds.right = x;
                if (y < component.bounds.top) component.bounds.top = y;
                if (y > component.bounds.bottom) component.bounds.bottom = y;

                // Add 4-connected neighbors - unrolled for better performance
                if (x + 1 < width) {
                    stack[stackTop++] = x + 1;
                    stack[stackTop++] = y;
                }
                if (x - 1 >= 0) {
                    stack[stackTop++] = x - 1;
                    stack[stackTop++] = y;
                }
                if (y + 1 < height) {
                    stack[stackTop++] = x;
                    stack[stackTop++] = y + 1;
                }
                if (y - 1 >= 0) {
                    stack[stackTop++] = x;
                    stack[stackTop++] = y - 1;
                }
            }

            return component;
        }

        // Helper function to reconstruct pixel coordinates from binary data for extraction
        function getPixelsFromBounds(bounds, binary, width) {
            const pixels = [];
            for (let y = bounds.top; y <= bounds.bottom; y++) {
                const rowOffset = y * width;
                for (let x = bounds.left; x <= bounds.right; x++) {
                    const idx = rowOffset + x;
                    if (binary[idx]) {
                        pixels.push({ x, y });
                    }
                }
            }
            return pixels;
        }

        function extractObject(objectData, originalImage, originalWidth, originalHeight, productId, objectNumber) {
            // Show loading feedback
            const infoDiv = document.getElementById(`objectInfo-${productId}`);
            if (infoDiv) {
                infoDiv.textContent = `Extracting Object ${objectNumber}...`;
                infoDiv.style.color = '#059669';
            }
            
            // Use setTimeout to allow UI to update
            setTimeout(() => {
                try {
                    // Create a new canvas with just this object
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    const bounds = objectData.bounds;
                    const padding = 20; // Add some padding around the object
                    
                    canvas.width = bounds.width + (padding * 2);
                    canvas.height = bounds.height + (padding * 2);
                    
                    // Fill with white
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Get original image data
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = originalWidth;
                    tempCanvas.height = originalHeight;
                    tempCtx.drawImage(originalImage, 0, 0);
                    const originalData = tempCtx.getImageData(0, 0, originalWidth, originalHeight);
                    
                    // Create new image data for just this object
                    const newImageData = ctx.createImageData(canvas.width, canvas.height);
                    const newData = newImageData.data;
                    
                    // Fill new canvas with white
                    for (let i = 0; i < newData.length; i += 4) {
                        newData[i] = 255;     // R
                        newData[i + 1] = 255; // G  
                        newData[i + 2] = 255; // B
                        newData[i + 3] = 255; // A
                    }
                    
                    // Copy only the pixels belonging to this object
                    objectData.getPixels().forEach(pixel => {
                        const sourceIdx = (pixel.y * originalWidth + pixel.x) * 4;
                        const targetX = pixel.x - bounds.left + padding;
                        const targetY = pixel.y - bounds.top + padding;
                        const targetIdx = (targetY * canvas.width + targetX) * 4;
                        
                        if (targetIdx >= 0 && targetIdx < newData.length) {
                            newData[targetIdx] = originalData.data[sourceIdx];         // R
                            newData[targetIdx + 1] = originalData.data[sourceIdx + 1]; // G
                            newData[targetIdx + 2] = originalData.data[sourceIdx + 2]; // B
                            newData[targetIdx + 3] = 255;                              // A
                        }
                    });
                    
                    ctx.putImageData(newImageData, 0, 0);
                    
                    // Convert to image and then to SVG
                    const extractedImage = new Image();
                    extractedImage.onload = async () => {
                        try {
                            const svg = await convertToSVG(extractedImage, canvas.width, canvas.height);
                            createExtractedObjectCard(svg, canvas.width, canvas.height, productId, objectNumber);
                            
                            // Restore info message
                            if (infoDiv) {
                                const objectsContainer = document.getElementById(`objects-${productId}`);
                                const objectCount = objectsContainer ? objectsContainer.children.length : 0;
                                const remainingOverlays = document.querySelectorAll('.object-overlay.detected').length;
                                if (remainingOverlays > 0) {
                                    infoDiv.textContent = `Object ${objectNumber} extracted! Click on remaining highlighted areas to extract more objects.`;
                                } else {
                                    infoDiv.textContent = `All visible objects have been extracted. You can adjust parameters and detect again to find different objects.`;
                                }
                            }
                        } catch (error) {
                            console.error('Error converting object to SVG:', error);
                            if (infoDiv) {
                                infoDiv.textContent = `Error extracting Object ${objectNumber}. Please try again.`;
                                infoDiv.style.color = '#dc2626';
                            }
                        }
                    };
                    extractedImage.src = canvas.toDataURL();
                } catch (error) {
                    console.error('Error during object extraction:', error);
                    if (infoDiv) {
                        infoDiv.textContent = `Error extracting Object ${objectNumber}. Please try again.`;
                        infoDiv.style.color = '#dc2626';
                    }
                }
            }, 50);
        }

        function createExtractedObjectCard(svgString, width, height, productId, objectNumber) {
            const objectsContainer = document.getElementById(`objects-${productId}`);
            if (!objectsContainer) return;
            
            // Show the objects header if this is the first object
            const objectsHeader = document.getElementById(`objectsHeader-${productId}`);
            if (objectsHeader && objectsContainer.children.length === 0) {
                objectsHeader.style.display = 'block';
            }
            
            // Create the object card
            const objectCard = document.createElement('div');
            objectCard.className = 'svg-object-card';
            
            // Create preview container
            const preview = document.createElement('div');
            preview.className = 'svg-object-preview';
            
            // Create SVG element
            const svgContainer = document.createElement('div');
            svgContainer.innerHTML = svgString;
            const svg = svgContainer.querySelector('svg');
            if (svg) {
                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
            }
            preview.appendChild(svg);
            
            // Create controls container
            const controls = document.createElement('div');
            controls.className = 'object-controls';
            
            // Create header
            const header = document.createElement('div');
            header.className = 'object-header';
            
            const title = document.createElement('span');
            title.textContent = `Object ${objectNumber}`;
            
            const actions = document.createElement('div');
            actions.className = 'object-actions';
            
            const removeButton = document.createElement('button');
            removeButton.className = 'remove-object-compact';
            removeButton.textContent = 'âœ•';
            removeButton.title = 'Remove';
            removeButton.onclick = () => objectCard.remove();

            const dlIcon = '<svg width="11" height="11" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" style="display:inline-block;vertical-align:-1px;margin-right:4px"><path d="M6 1v7M3.5 5.5L6 8l2.5-2.5M2 10.5h8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';

            const downloadButton = document.createElement('button');
            downloadButton.innerHTML = dlIcon + 'SVG';
            downloadButton.onclick = () => downloadObjectSVG(svg, productId, width, height);

            const downloadJpgButton = document.createElement('button');
            downloadJpgButton.innerHTML = dlIcon + 'JPG';
            downloadJpgButton.onclick = () => downloadObjectJPG(svg, productId, width, height);

            const bufferInput = document.createElement('input');
            bufferInput.type = 'number';
            bufferInput.min = '5';
            bufferInput.max = '60';
            bufferInput.value = '25';
            bufferInput.title = 'Cricut cut border (px)';

            const cricutButton = document.createElement('button');
            cricutButton.textContent = 'âœ‚ Cricut PNG';
            cricutButton.onclick = () => {
                const buf = Math.max(5, Math.min(60, parseInt(bufferInput.value, 10) || 15));
                generateCricutPNG(svg, productId, width, height, buf);
            };

            header.appendChild(title);
            header.appendChild(removeButton);

            const actionRow = document.createElement('div');
            actionRow.className = 'object-action-row';

            const divider = document.createElement('div');
            divider.className = 'action-divider';

            const cricutGroup = document.createElement('div');
            cricutGroup.className = 'cricut-group';
            cricutGroup.appendChild(bufferInput);
            cricutGroup.appendChild(cricutButton);

            actionRow.appendChild(downloadButton);
            actionRow.appendChild(downloadJpgButton);
            actionRow.appendChild(divider);
            actionRow.appendChild(cricutGroup);

            // Create color controls for the object
            const colorControl = createObjectColorControls(svg);

            controls.appendChild(header);
            controls.appendChild(actionRow);
            controls.appendChild(colorControl);
            
            objectCard.appendChild(preview);
            objectCard.appendChild(controls);
            
            objectsContainer.appendChild(objectCard);
            
            // Scroll to the new object card
            objectCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function createObjectColorControls(svg) {
            const colorControl = document.createElement('div');
            colorControl.className = 'color-control';
            
            // Create color inputs container
            const colorInputs = document.createElement('div');
            colorInputs.className = 'color-inputs';
            
            const colorPicker = document.createElement('input');
            colorPicker.type = 'color';
            colorPicker.className = 'color-picker';
            colorPicker.value = '#000000';
            
            const hexInput = document.createElement('input');
            hexInput.type = 'text';
            hexInput.className = 'hex-input';
            hexInput.value = '#000000';
            hexInput.placeholder = '#000000';

            // Add palette selector
            const paletteSelector = document.createElement('select');
            paletteSelector.className = 'palette-selector';
            
            // Add color palettes (reusing the same palettes from main controls)
            const colorPalettes = {
                "2025-2027 In Colors": {
                    "Strawberry Slush": "#f26b73",
                    "Timid Tiger": "#f68e4f",
                    "Darling Duckling": "#f0d34f",
                    "Cloud Cover": "#b4c5c0",
                    "Secret Sea": "#334249"
                },
                "2024-2026 In Colors": {
                    "Pretty in Pink": "#f8abb6",
                    "Peach Pie": "#fab474",
                    "Shy Shamrock": "#49bc8f",
                    "Summer Splash": "#63c4b1",
                    "Petunia Pop": "#d37eb4"
                },
                "Basics": {
                    "Basic Beige": "#e3dbc5",
                    "Very Vanilla": "#fff7e1",
                    "Basic White": "#ffffff",
                    "White Willow": "#ffffff",
                    "Basic Black": "#000000",
                    "Bronze & Ivory": "#a97448",
                    "Crumb Cake": "#c8ad8c"
                },
                "Subtles": {
                    "Petal Pink": "#fcd1bb",
                    "Calypso Coral": "#f47e63",
                    "Lemon Lolly": "#fff8a2",
                    "Soft Sea Foam": "#e6f1d2",
                    "Lost Lagoon": "#7baaa1",
                    "Pool Party": "#a9dbd6",
                    "Balmy Blue": "#a0d6ea",
                    "Highland Heather": "#ad95c6",
                    "Fresh Freesia": "#e6b7d6",
                    "Bubble Bath": "#fad5e6"
                },
                "Brights": {
                    "Poppy Parade": "#ed193a",
                    "Melon Mambo": "#e94d87",
                    "Flirty Flamingo": "#f5928b",
                    "Pumpkin Pie": "#f89433",
                    "Daffodil Delight": "#ffdc67",
                    "Lemon Lime Twist": "#dee568",
                    "Granny Apple Green": "#a3c149",
                    "Coastal Cabana": "#90d2be",
                    "Azure Afternoon": "#27a0d6",
                    "Berry Burst": "#b74985"
                },
                "Regals": {
                    "Cherry Cobbler": "#a10637",
                    "Real Red": "#c52342",
                    "Cajun Craze": "#c0492d",
                    "Crushed Curry": "#f8bd16",
                    "Old Olive": "#98a04d",
                    "Garden Green": "#4d8b56",
                    "Shaded Spruce": "#00815b",
                    "Pretty Peacock": "#006f71",
                    "Blueberry Bushel": "#0d5993",
                    "Gorgeous Grape": "#855da4"
                },
                "Neutrals": {
                    "Mossy Meadow": "#656739",
                    "Misty Moonlight": "#58728e",
                    "Night of Navy": "#213e6d",
                    "Blackberry Bliss": "#582752",
                    "Early Espresso": "#63412c",
                    "Pecan Pie": "#a97448",
                    "Crumb Cake": "#c8ad8c",
                    "Gray Granite": "#b3aba1",
                    "Smoky Slate": "#bdbdbe",
                    "Basic Gray": "#767e85"
                }
            };

            // Add options to palette selector
            Object.keys(colorPalettes).forEach(paletteName => {
                const option = document.createElement('option');
                option.value = paletteName;
                option.textContent = paletteName;
                paletteSelector.appendChild(option);
            });

            // Create color palette container
            const colorPalette = document.createElement('div');
            colorPalette.className = 'color-palette';

            // Function to update color palette
            function updateColorPalette(paletteName) {
                colorPalette.innerHTML = '';
                const colors = colorPalettes[paletteName];
                
                Object.entries(colors).forEach(([name, hex]) => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = hex;
                    swatch.title = name;
                    
                    swatch.addEventListener('click', () => {
                        // Remove active class from all swatches
                        colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                        // Add active class to clicked swatch
                        swatch.classList.add('active');
                        
                        // Update color picker and hex input
                        colorPicker.value = hex;
                        hexInput.value = hex;
                        tintSVG(svg, hex);
                    });
                    
                    colorPalette.appendChild(swatch);
                });
            }

            // Initial palette update
            updateColorPalette(paletteSelector.value);

            // Update palette when selection changes
            paletteSelector.addEventListener('change', (e) => {
                updateColorPalette(e.target.value);
            });
            
            // Sync color picker and hex input
            colorPicker.addEventListener('input', (e) => {
                const color = e.target.value;
                hexInput.value = color;
                tintSVG(svg, color);
                // Remove active class from all swatches
                colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            });
            
            hexInput.addEventListener('input', (e) => {
                let color = e.target.value;
                // Add # if missing
                if (color.charAt(0) !== '#') {
                    color = '#' + color;
                }
                // Validate hex color
                if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                    colorPicker.value = color;
                    tintSVG(svg, color);
                    // Remove active class from all swatches
                    colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                }
            });
            
            // Assemble the structure
            colorInputs.appendChild(colorPicker);
            colorInputs.appendChild(hexInput);
            
            colorControl.appendChild(colorInputs);
            colorControl.appendChild(paletteSelector);
            
            // Create a container for the palette
            const paletteContainer = document.createElement('div');
            paletteContainer.appendChild(colorPalette);
            
            const fullControl = document.createElement('div');
            fullControl.appendChild(colorControl);
            fullControl.appendChild(paletteContainer);
            
            return fullControl;
        }

        function sanitizeForFilename(name) {
            return name
                .trim()
                .toLowerCase()
                .replace(/[^a-z0-9\s-]/g, '')
                .replace(/\s+/g, '_')
                .replace(/_+/g, '_')
                .replace(/^_|_$/g, '');
        }

        function buildDownloadFilename(productId, suffix) {
            const sanitized = sanitizeForFilename(detectedStampSetName);
            const parts = ['stampinup', productId];
            if (sanitized) parts.push(sanitized);
            if (suffix) parts.push(suffix);
            return parts.join('_') + '.svg';
        }

        function downloadObjectSVG(svg, productId, originalWidth, originalHeight) {
            if (!svg) return;

            const svgCopy = svg.cloneNode(true);
            svgCopy.setAttribute('viewBox', `0 0 ${originalWidth} ${originalHeight}`);
            svgCopy.setAttribute('width', originalWidth);
            svgCopy.setAttribute('height', originalHeight);

            const svgData = new XMLSerializer().serializeToString(svgCopy);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });

            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = buildDownloadFilename(productId, `object_${Date.now()}`);

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function downloadObjectPNG(svg, productId, originalWidth, originalHeight) {
            if (!svg) return;
            svgToImageBlob(svg, originalWidth, originalHeight, 'image/png', blob => {
                triggerDownload(blob, buildDownloadFilename(productId, `object_${Date.now()}`).replace(/\.svg$/, '.png'));
            });
        }

        function downloadObjectJPG(svg, productId, originalWidth, originalHeight) {
            if (!svg) return;
            svgToImageBlob(svg, originalWidth, originalHeight, 'image/jpeg', blob => {
                triggerDownload(blob, buildDownloadFilename(productId, `object_${Date.now()}`).replace(/\.svg$/, '.jpg'));
            });
        }

        function downloadSVG(svg, productId, originalWidth, originalHeight) {
            if (!svg) return;
            
            // Create a copy of the SVG to modify
            const svgCopy = svg.cloneNode(true);
            
            // Set the viewBox to match original dimensions
            svgCopy.setAttribute('viewBox', `0 0 ${originalWidth} ${originalHeight}`);
            
            // Set width and height to match original dimensions
            svgCopy.setAttribute('width', originalWidth);
            svgCopy.setAttribute('height', originalHeight);
            
            // Create a blob from the SVG
            const svgData = new XMLSerializer().serializeToString(svgCopy);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            
            // Create a download link
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = buildDownloadFilename(productId);
            
            // Trigger the download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function svgToImageBlob(svg, originalWidth, originalHeight, mimeType, callback) {
            const svgCopy = svg.cloneNode(true);
            svgCopy.setAttribute('viewBox', `0 0 ${originalWidth} ${originalHeight}`);
            svgCopy.setAttribute('width', originalWidth);
            svgCopy.setAttribute('height', originalHeight);

            const svgData = new XMLSerializer().serializeToString(svgCopy);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml' });
            const svgUrl = URL.createObjectURL(svgBlob);

            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = originalWidth;
                canvas.height = originalHeight;
                const ctx = canvas.getContext('2d');
                if (mimeType === 'image/jpeg') {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, originalWidth, originalHeight);
                }
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(svgUrl);
                canvas.toBlob(callback, mimeType);
            };
            img.src = svgUrl;
        }

        function triggerDownload(blob, filename) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function downloadPNG(svg, productId, originalWidth, originalHeight) {
            if (!svg) return;
            svgToImageBlob(svg, originalWidth, originalHeight, 'image/png', blob => {
                triggerDownload(blob, buildDownloadFilename(productId).replace(/\.svg$/, '.png'));
            });
        }

        function downloadJPG(svg, productId, originalWidth, originalHeight) {
            if (!svg) return;
            svgToImageBlob(svg, originalWidth, originalHeight, 'image/jpeg', blob => {
                triggerDownload(blob, buildDownloadFilename(productId).replace(/\.svg$/, '.jpg'));
            });
        }

        // --- Cricut "Print Then Cut" export ---

        function renderSVGOffscreen(svg, origW, origH, targetW, targetH) {
            return new Promise((resolve, reject) => {
                const svgCopy = svg.cloneNode(true);
                svgCopy.setAttribute('viewBox', `0 0 ${origW} ${origH}`);
                svgCopy.setAttribute('width', targetW);
                svgCopy.setAttribute('height', targetH);

                const svgData = new XMLSerializer().serializeToString(svgCopy);
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml' });
                const svgUrl = URL.createObjectURL(svgBlob);

                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = targetW;
                    canvas.height = targetH;
                    const ctx = canvas.getContext('2d');
                    // Draw on transparent background (no fill)
                    ctx.drawImage(img, 0, 0);
                    URL.revokeObjectURL(svgUrl);
                    resolve(canvas);
                };
                img.onerror = (e) => {
                    URL.revokeObjectURL(svgUrl);
                    reject(e);
                };
                img.src = svgUrl;
            });
        }

        function dilateCircular(silhouette, w, h, radius) {
            // Circular dilation via canvas Gaussian blur + alpha threshold.
            // Produces smooth, rounded borders (no boxy/flat edges from box kernels).
            // sigma = radius/3 so the 3-sigma point sits at ~radius px from the silhouette.
            const sigma = radius / 3;

            // Draw silhouette as white-on-transparent onto a source canvas
            const srcCanvas = document.createElement('canvas');
            srcCanvas.width = w;
            srcCanvas.height = h;
            const srcCtx = srcCanvas.getContext('2d');
            const imgData = srcCtx.createImageData(w, h);
            for (let i = 0; i < silhouette.length; i++) {
                if (silhouette[i]) {
                    imgData.data[i * 4]     = 255;
                    imgData.data[i * 4 + 1] = 255;
                    imgData.data[i * 4 + 2] = 255;
                    imgData.data[i * 4 + 3] = 255;
                }
            }
            srcCtx.putImageData(imgData, 0, 0);

            // Blur onto a destination canvas â€” spreads signal circularly
            const dstCanvas = document.createElement('canvas');
            dstCanvas.width = w;
            dstCanvas.height = h;
            const dstCtx = dstCanvas.getContext('2d');
            dstCtx.filter = `blur(${sigma}px)`;
            dstCtx.drawImage(srcCanvas, 0, 0);
            dstCtx.filter = 'none';

            // Threshold alpha > 1: captures all pixels within ~radius of the silhouette
            const blurred = dstCtx.getImageData(0, 0, w, h);
            const result = new Uint8Array(w * h);
            for (let i = 0; i < result.length; i++) {
                result[i] = blurred.data[i * 4 + 3] > 1 ? 1 : 0;
            }
            return result;
        }

        async function generateCricutPNG(svg, productId, width, height, bufferPx) {
            // Render at 2x resolution for quality
            const scale = 2;
            const bufferScaled = bufferPx * scale;

            // Pad by 2Ã— bufferScaled on each side: the dilation expands by bufferScaled,
            // leaving another bufferScaled of transparent space so the border never
            // gets clipped even when ink touches the SVG's own viewBox boundary.
            const pad = bufferScaled * 2;
            const tw = width * scale + pad * 2;
            const th = height * scale + pad * 2;

            // Render SVG at its natural 2x size, then place it centred on the padded canvas
            const svgCanvas = await renderSVGOffscreen(svg, width, height, width * scale, height * scale);
            const renderCanvas = document.createElement('canvas');
            renderCanvas.width = tw;
            renderCanvas.height = th;
            renderCanvas.getContext('2d').drawImage(svgCanvas, pad, pad);

            const ctx = renderCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, tw, th);
            const data = imageData.data;
            const n = tw * th;

            // Step 1: Classify ink pixels (alpha > 32)
            const isInk = new Uint8Array(n);
            for (let i = 0; i < n; i++) {
                isInk[i] = data[i * 4 + 3] > 32 ? 1 : 0;
            }

            // Step 2: BFS flood fill from all 4 edges through non-ink pixels â†’ isExterior
            const isExterior = new Uint8Array(n);
            const queue = new Int32Array(n);
            let head = 0, tail = 0;

            const enqueue = (idx) => {
                if (isInk[idx] || isExterior[idx]) return;
                isExterior[idx] = 1;
                queue[tail++] = idx;
            };

            // Seed edges
            for (let x = 0; x < tw; x++) {
                enqueue(x);                    // top row
                enqueue((th - 1) * tw + x);   // bottom row
            }
            for (let y = 0; y < th; y++) {
                enqueue(y * tw);               // left col
                enqueue(y * tw + tw - 1);      // right col
            }

            // BFS
            while (head < tail) {
                const idx = queue[head++];
                const x = idx % tw;
                const y = (idx / tw) | 0;
                if (x > 0)      enqueue(idx - 1);
                if (x < tw - 1) enqueue(idx + 1);
                if (y > 0)      enqueue(idx - tw);
                if (y < th - 1) enqueue(idx + tw);
            }

            // Step 3: Build silhouette mask (ink + interior non-ink)
            const silhouette = new Uint8Array(n);
            for (let i = 0; i < n; i++) {
                silhouette[i] = (isInk[i] || !isExterior[i]) ? 1 : 0;
            }

            // Step 4: Dilate silhouette by bufferScaled pixels
            const dilated = dilateCircular(silhouette, tw, th, bufferScaled);

            // Step 5: Second BFS from edges through non-dilated pixels to find the
            // true exterior. The dilated border acts as a solid wall, so any pixel
            // enclosed inside it (including interior holes that leaked through thin
            // ink seams) will NOT be reached and should be filled white.
            const trulyExterior = new Uint8Array(n);
            const queue2 = new Int32Array(n);
            let head2 = 0, tail2 = 0;

            const enqueue2 = (idx) => {
                if (dilated[idx] || trulyExterior[idx]) return;
                trulyExterior[idx] = 1;
                queue2[tail2++] = idx;
            };

            for (let x = 0; x < tw; x++) {
                enqueue2(x);
                enqueue2((th - 1) * tw + x);
            }
            for (let y = 0; y < th; y++) {
                enqueue2(y * tw);
                enqueue2(y * tw + tw - 1);
            }

            while (head2 < tail2) {
                const idx = queue2[head2++];
                const x = idx % tw;
                const y = (idx / tw) | 0;
                if (x > 0)      enqueue2(idx - 1);
                if (x < tw - 1) enqueue2(idx + 1);
                if (y > 0)      enqueue2(idx - tw);
                if (y < th - 1) enqueue2(idx + tw);
            }

            // Step 6: Smooth the outer edge of the white region with a small blur.
            // This anti-aliases the pixel staircase on the border without visibly
            // changing the border size â€” interior pixels stay fully opaque (255),
            // only the outermost few pixels get a smooth alpha falloff.
            const edgeSrc = document.createElement('canvas');
            edgeSrc.width = tw;
            edgeSrc.height = th;
            const edgeSrcCtx = edgeSrc.getContext('2d');
            const edgeSrcData = edgeSrcCtx.createImageData(tw, th);
            for (let i = 0; i < n; i++) {
                if (dilated[i] || !trulyExterior[i]) {
                    edgeSrcData.data[i * 4]     = 255;
                    edgeSrcData.data[i * 4 + 1] = 255;
                    edgeSrcData.data[i * 4 + 2] = 255;
                    edgeSrcData.data[i * 4 + 3] = 255;
                }
            }
            edgeSrcCtx.putImageData(edgeSrcData, 0, 0);

            const edgeDst = document.createElement('canvas');
            edgeDst.width = tw;
            edgeDst.height = th;
            const edgeDstCtx = edgeDst.getContext('2d');
            edgeDstCtx.filter = 'blur(1.5px)';
            edgeDstCtx.drawImage(edgeSrc, 0, 0);
            edgeDstCtx.filter = 'none';
            const smoothedEdge = edgeDstCtx.getImageData(0, 0, tw, th).data;

            const outData = new ImageData(tw, th);
            const out = outData.data;
            for (let i = 0; i < n; i++) {
                const a = smoothedEdge[i * 4 + 3];
                if (a > 0) {
                    out[i * 4]     = 255;
                    out[i * 4 + 1] = 255;
                    out[i * 4 + 2] = 255;
                    out[i * 4 + 3] = a;   // smooth falloff at the outer edge
                }
            }

            // Draw white backing, then stamp ink on top
            const outCanvas = document.createElement('canvas');
            outCanvas.width = tw;
            outCanvas.height = th;
            const outCtx = outCanvas.getContext('2d');
            outCtx.putImageData(outData, 0, 0);
            outCtx.drawImage(renderCanvas, 0, 0);

            outCanvas.toBlob(blob => {
                const filename = buildDownloadFilename(productId, `object_${Date.now()}_cricut`).replace(/\.svg$/, '.png');
                triggerDownload(blob, filename);
            }, 'image/png');
        }
    </script>
</body>
</html> 