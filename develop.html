<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stampin' Up Image Viewer</title>
    <script src="potrace.js"></script>
    <style>
        :root {
            --primary-color: #2563eb;
            --border-radius: 8px;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background-color: #f8fafc;
            color: #1e293b;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        h1 {
            font-size: 2rem;
            font-weight: 600;
            margin: 0;
            color: #0f172a;
        }

        .input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
            background: white;
            padding: 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
        }

        input[type="number"] {
            padding: 0.75rem 1rem;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            font-size: 1rem;
            width: 200px;
            transition: border-color 0.15s ease;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        button {
            padding: 0.75rem 1.5rem;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        button:hover {
            background-color: #1d4ed8;
        }

        .image-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            width: 100%;
        }

        .image-wrapper {
            background: white;
            padding: 1.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .image-wrapper img {
            max-width: 100%;
            height: auto;
            border-radius: calc(var(--border-radius) - 2px);
        }

        .controls {
            display: flex;
            gap: 1rem;
            padding-top: 0.5rem;
            border-top: 1px solid #e2e8f0;
            align-items: center;
            flex-direction: column;
        }

        .color-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            justify-content: space-between;
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.75rem;
            background: #f8fafc;
            border-radius: var(--border-radius);
            width: 100%;
            justify-content: center;
            border: 1px solid #e2e8f0;
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        /* Responsive color palette for individual object cards */
        .svg-object-card .color-palette {
            gap: 0.25rem;
            padding: 0.5rem;
            justify-content: flex-start;
        }

        .svg-object-card .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        /* Responsive control layout for individual object cards */
        .svg-object-card .color-control {
            flex-direction: column;
            gap: 0.5rem;
            align-items: stretch;
        }

        .svg-object-card .color-inputs {
            justify-content: center;
        }

        .svg-object-card .palette-selector {
            min-width: 100px;
        }

        .svg-object-card .hex-input {
            width: 80px;
        }

        .svg-object-card .color-picker {
            width: 40px;
            height: 35px;
        }

        .color-swatch:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .color-swatch.active {
            outline: 3px solid var(--primary-color);
            outline-offset: 2px;
            transform: scale(1.1);
        }

        .palette-selector {
            padding: 0.5rem 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            font-size: 0.875rem;
            background: white;
            cursor: pointer;
            min-width: 120px;
        }

        .palette-selector:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .color-inputs {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .color-picker {
            width: 50px;
            height: 40px;
            padding: 0;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            cursor: pointer;
        }

        .hex-input {
            width: 90px;
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            font-family: monospace;
            font-size: 0.875rem;
        }

        .hex-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .error {
            color: #dc2626;
            font-size: 0.875rem;
            padding: 0.75rem 1rem;
            background-color: #fef2f2;
            border: 1px solid #fee2e2;
            border-radius: var(--border-radius);
            display: none;
        }

        .error:not(:empty) {
            display: block;
        }

        .svg-container {
            margin: 0;
            border: 1px solid #e2e8f0;
            padding: 0;
            width: 100%;
            aspect-ratio: 1;
            overflow: hidden;
            position: relative;
            background: #fff;
            border-radius: calc(var(--border-radius) - 2px);
        }

        .svg-container svg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .svg-objects-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .svg-object-card {
            background: white;
            padding: 1rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            border: 2px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .svg-object-card.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .svg-object-preview {
            width: 100%;
            height: 150px;
            border: 1px solid #e2e8f0;
            border-radius: calc(var(--border-radius) - 2px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fff;
            overflow: hidden;
        }

        .svg-object-preview svg {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        .object-controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .object-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            color: #374151;
        }

        .object-actions {
            display: flex;
            gap: 0.5rem;
        }

        .object-actions button {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .remove-object {
            background-color: #dc2626;
        }

        .remove-object:hover {
            background-color: #b91c1c;
        }

        .svg-container path {
            cursor: pointer;
            transition: opacity 0.15s ease;
        }

        .svg-container path:hover {
            opacity: 0.7;
        }

        .svg-container path.selected {
            stroke: var(--primary-color);
            stroke-width: 2;
            stroke-dasharray: 5,5;
        }

        .objects-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .break-off-hint {
            font-size: 0.875rem;
            color: #6b7280;
            text-align: center;
            padding: 0.75rem;
            background: #f9fafb;
            border-radius: var(--border-radius);
            border: 1px dashed #d1d5db;
        }

        .object-detection-controls {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            padding: 1rem;
            margin: 1rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-group label {
            font-size: 0.875rem;
            color: #374151;
            min-width: 120px;
        }

        .range-input {
            width: 150px;
        }

        .range-value {
            font-family: monospace;
            font-size: 0.875rem;
            color: #6b7280;
            min-width: 40px;
        }

        .detect-button {
            background-color: #059669;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .detect-button:hover {
            background-color: #047857;
        }

        .detect-button:disabled {
            background-color: #9ca3af !important;
            cursor: not-allowed !important;
            opacity: 0.7;
        }

        .detect-button:disabled:hover {
            background-color: #9ca3af !important;
        }

        .object-overlay {
            position: absolute;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.15s ease;
            border-radius: 4px;
        }

        .object-overlay:hover {
            border-color: var(--primary-color);
            background-color: rgba(37, 99, 235, 0.1);
        }

        .object-overlay.detected {
            border-color: #10b981;
            background-color: rgba(16, 185, 129, 0.1);
        }

        .object-count-info {
            font-size: 0.875rem;
            color: #059669;
            font-weight: 500;
            text-align: center;
        }

        .detection-toggle {
            background: none;
            border: 1px solid #e2e8f0;
            border-radius: var(--border-radius);
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            justify-content: space-between;
            transition: all 0.15s ease;
            font-weight: 500;
        }

        .detection-toggle:hover {
            background-color: #f9fafb;
            border-color: #d1d5db;
        }

        .detection-toggle-icon {
            transition: transform 0.15s ease;
            font-size: 0.75rem;
            color: #6b7280;
        }

        .detection-toggle.expanded .detection-toggle-icon {
            transform: rotate(180deg);
        }

        .detection-params {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            max-height: 0;
            opacity: 0;
        }

        .detection-params.expanded {
            max-height: 200px;
            opacity: 1;
            padding-top: 1rem;
        }

        /* Better responsive styling for object card color palettes */
        .svg-object-card .color-palette {
            justify-content: center !important;
            padding: 0.6rem !important;
            gap: 0.3rem !important;
            margin: 0 auto !important;
            max-width: 100% !important;
        }

        .svg-object-card .color-swatch {
            width: 22px !important;
            height: 22px !important;
        }

        /* Keep color controls on same line in object cards */
        .svg-object-card .color-control {
            flex-direction: row !important;
            align-items: center !important;
            justify-content: space-between !important;
        }

        .svg-object-card .palette-selector {
            flex: 1 !important;
            margin-left: 0.5rem !important;
        }

        /* Add spacing between color controls and palette */
        .svg-object-card .color-control {
            margin-bottom: 0.75rem !important;
        }

        /* Prevent palette from touching card edges */
        .svg-object-card .color-palette {
            margin-left: 0.5rem !important;
            margin-right: 0.5rem !important;
            max-width: calc(100% - 1rem) !important;
            width: auto !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Stampin' Up Image Viewer</h1>
        <div class="input-group">
            <input type="number" id="productId" placeholder="Enter product ID" min="1" value="165346">
            <button onclick="loadImages()">Load Images</button>
        </div>
        <div id="error" class="error"></div>
        <div class="image-container" id="imageContainer"></div>
    </div>

    <script>
        const baseUrl = 'https://res.cloudinary.com/stampin-up/image/upload/prod/images/default-source/product-image';

        // Add event listener for Enter key
        document.getElementById('productId').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                loadImages();
            }
        });

        // Load images automatically on page load
        window.onload = function() {
            loadImages();
        };

        async function loadImages() {
            const productId = document.getElementById('productId').value;
            const errorDiv = document.getElementById('error');
            const imageContainer = document.getElementById('imageContainer');
            
            if (!productId) {
                errorDiv.textContent = 'Please enter a product ID';
                return;
            }

            errorDiv.textContent = '';
            imageContainer.innerHTML = '';

            const imageUrls = [
                `${baseUrl}/${productId}.jpg`,
                `${baseUrl}/${productId}o01.jpg`
            ];

            for (const url of imageUrls) {
                try {
                    const response = await fetch(url);
                    if (response.ok) {
                        const blob = await response.blob();
                        
                        const imageWrapper = document.createElement('div');
                        imageWrapper.className = 'image-wrapper';
                        
                        if (url.includes('o01')) {
                            // Create a temporary image to get dimensions
                            const tempImg = document.createElement('img');
                            tempImg.src = URL.createObjectURL(blob);
                            
                            // Wait for image to load
                            await new Promise(resolve => {
                                tempImg.onload = resolve;
                            });
                            
                            const originalWidth = tempImg.naturalWidth;
                            const originalHeight = tempImg.naturalHeight;
                            
                            const isBW = await isBlackAndWhite(tempImg);
                            if (isBW) {
                                // Convert to SVG automatically
                                const svg = await convertToSVG(tempImg, originalWidth, originalHeight);
                                const svgContainer = document.createElement('div');
                                svgContainer.className = 'svg-container';
                                
                                // Scale the SVG for display
                                const displayScale = Math.min(280 / originalWidth, 280 / originalHeight);
                                const scaledSvg = svg.replace(/<svg([^>]*)>/, (match, attributes) => {
                                    return `<svg${attributes} viewBox="0 0 ${originalWidth} ${originalHeight}" width="100%" height="100%">`;
                                });
                                
                                svgContainer.innerHTML = scaledSvg;
                                imageWrapper.appendChild(svgContainer);
                                
                                // Add object detection controls
                                const detectionControls = createObjectDetectionControls(tempImg, svgContainer, originalWidth, originalHeight, productId);
                                imageWrapper.appendChild(detectionControls);

                                // Add main image controls (before objects container)
                                const mainControlsHeader = document.createElement('h3');
                                mainControlsHeader.textContent = 'Full Image Controls';
                                mainControlsHeader.style.fontSize = '1rem';
                                mainControlsHeader.style.fontWeight = '600';
                                mainControlsHeader.style.color = '#374151';
                                mainControlsHeader.style.margin = '1.5rem 0 0.5rem 0';
                                imageWrapper.appendChild(mainControlsHeader);

                                const controls = document.createElement('div');
                                controls.className = 'controls';
                                
                                const colorControl = document.createElement('div');
                                colorControl.className = 'color-control';
                                
                                // Create color inputs container
                                const colorInputs = document.createElement('div');
                                colorInputs.className = 'color-inputs';
                                
                                const colorPicker = document.createElement('input');
                                colorPicker.type = 'color';
                                colorPicker.className = 'color-picker';
                                colorPicker.value = '#000000';
                                
                                const hexInput = document.createElement('input');
                                hexInput.type = 'text';
                                hexInput.className = 'hex-input';
                                hexInput.value = '#000000';
                                hexInput.placeholder = '#000000';

                                // Add palette selector
                                const paletteSelector = document.createElement('select');
                                paletteSelector.className = 'palette-selector';
                                
                                // Add color palettes
                                const colorPalettes = {
                                    "2025-2027 In Colors": {
                                        "Strawberry Slush": "#f26b73",
                                        "Timid Tiger": "#f68e4f",
                                        "Darling Duckling": "#f0d34f",
                                        "Cloud Cover": "#b4c5c0",
                                        "Secret Sea": "#334249"
                                    },
                                    "2024-2026 In Colors": {
                                        "Pretty in Pink": "#f8abb6",
                                        "Peach Pie": "#fab474",
                                        "Shy Shamrock": "#49bc8f",
                                        "Summer Splash": "#63c4b1",
                                        "Petunia Pop": "#d37eb4"
                                    },
                                    "Basics": {
                                        "Basic Beige": "#e3dbc5",
                                        "Very Vanilla": "#fff7e1",
                                        "Basic White": "#ffffff",
                                        "White Willow": "#ffffff",
                                        "Basic Black": "#000000",
                                        "Bronze & Ivory": "#a97448",
                                        "Crumb Cake": "#c8ad8c"
                                    },
                                    "Subtles": {
                                        "Petal Pink": "#fcd1bb",
                                        "Calypso Coral": "#f47e63",
                                        "Lemon Lolly": "#fff8a2",
                                        "Soft Sea Foam": "#e6f1d2",
                                        "Lost Lagoon": "#7baaa1",
                                        "Pool Party": "#a9dbd6",
                                        "Balmy Blue": "#a0d6ea",
                                        "Highland Heather": "#ad95c6",
                                        "Fresh Freesia": "#e6b7d6",
                                        "Bubble Bath": "#fad5e6"
                                    },
                                    "Brights": {
                                        "Poppy Parade": "#ed193a",
                                        "Melon Mambo": "#e94d87",
                                        "Flirty Flamingo": "#f5928b",
                                        "Pumpkin Pie": "#f89433",
                                        "Daffodil Delight": "#ffdc67",
                                        "Lemon Lime Twist": "#dee568",
                                        "Granny Apple Green": "#a3c149",
                                        "Coastal Cabana": "#90d2be",
                                        "Azure Afternoon": "#27a0d6",
                                        "Berry Burst": "#b74985"
                                    },
                                    "Regals": {
                                        "Cherry Cobbler": "#a10637",
                                        "Real Red": "#c52342",
                                        "Cajun Craze": "#c0492d",
                                        "Crushed Curry": "#f8bd16",
                                        "Old Olive": "#98a04d",
                                        "Garden Green": "#4d8b56",
                                        "Shaded Spruce": "#00815b",
                                        "Pretty Peacock": "#006f71",
                                        "Blueberry Bushel": "#0d5993",
                                        "Gorgeous Grape": "#855da4"
                                    },
                                    "Neutrals": {
                                        "Mossy Meadow": "#656739",
                                        "Misty Moonlight": "#58728e",
                                        "Night of Navy": "#213e6d",
                                        "Blackberry Bliss": "#582752",
                                        "Early Espresso": "#63412c",
                                        "Pecan Pie": "#a97448",
                                        "Crumb Cake": "#c8ad8c",
                                        "Gray Granite": "#b3aba1",
                                        "Smoky Slate": "#bdbdbe",
                                        "Basic Gray": "#767e85"
                                    }
                                };

                                // Add options to palette selector
                                Object.keys(colorPalettes).forEach(paletteName => {
                                    const option = document.createElement('option');
                                    option.value = paletteName;
                                    option.textContent = paletteName;
                                    paletteSelector.appendChild(option);
                                });

                                // Create color palette container
                                const colorPalette = document.createElement('div');
                                colorPalette.className = 'color-palette';

                                // Function to update color palette
                                function updateColorPalette(paletteName) {
                                    colorPalette.innerHTML = '';
                                    const colors = colorPalettes[paletteName];
                                    
                                    Object.entries(colors).forEach(([name, hex]) => {
                                        const swatch = document.createElement('div');
                                        swatch.className = 'color-swatch';
                                        swatch.style.backgroundColor = hex;
                                        swatch.title = name;
                                        
                                        swatch.addEventListener('click', () => {
                                            // Remove active class from all swatches
                                            colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                                            // Add active class to clicked swatch
                                            swatch.classList.add('active');
                                            
                                            // Update color picker and hex input
                                            colorPicker.value = hex;
                                            hexInput.value = hex;
                                            tintSVG(svgContainer.querySelector('svg'), hex);
                                        });
                                        
                                        colorPalette.appendChild(swatch);
                                    });
                                }

                                // Initial palette update
                                updateColorPalette(paletteSelector.value);

                                // Update palette when selection changes
                                paletteSelector.addEventListener('change', (e) => {
                                    updateColorPalette(e.target.value);
                                });
                                
                                // Sync color picker and hex input
                                colorPicker.addEventListener('input', (e) => {
                                    const color = e.target.value;
                                    hexInput.value = color;
                                    tintSVG(svgContainer.querySelector('svg'), color);
                                    // Remove active class from all swatches
                                    colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                                });
                                
                                hexInput.addEventListener('input', (e) => {
                                    let color = e.target.value;
                                    // Add # if missing
                                    if (color.charAt(0) !== '#') {
                                        color = '#' + color;
                                    }
                                    // Validate hex color
                                    if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                                        colorPicker.value = color;
                                        tintSVG(svgContainer.querySelector('svg'), color);
                                        // Remove active class from all swatches
                                        colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                                    }
                                });
                                
                                // Assemble the structure
                                colorInputs.appendChild(colorPicker);
                                colorInputs.appendChild(hexInput);
                                
                                colorControl.appendChild(colorInputs);
                                colorControl.appendChild(paletteSelector);
                                
                                const downloadButton = document.createElement('button');
                                downloadButton.textContent = 'Download SVG';
                                downloadButton.onclick = () => downloadSVG(svgContainer.querySelector('svg'), productId, originalWidth, originalHeight);
                                
                                controls.appendChild(colorControl);
                                controls.appendChild(colorPalette);
                                controls.appendChild(downloadButton);
                                
                                imageWrapper.appendChild(controls);

                                // Create container for individual objects
                                const objectsHeader = document.createElement('h3');
                                objectsHeader.textContent = 'Individual Objects';
                                objectsHeader.style.fontSize = '1rem';
                                objectsHeader.style.fontWeight = '600';
                                objectsHeader.style.color = '#374151';
                                objectsHeader.style.margin = '1.5rem 0 0.5rem 0';
                                objectsHeader.id = `objectsHeader-${productId}`;
                                objectsHeader.style.display = 'none'; // Initially hidden
                                imageWrapper.appendChild(objectsHeader);

                                const objectsContainer = document.createElement('div');
                                objectsContainer.className = 'objects-container';
                                objectsContainer.id = `objects-${productId}`;
                                imageWrapper.appendChild(objectsContainer);
                            } else {
                                // If not black and white, show original image
                                const img = document.createElement('img');
                                img.src = URL.createObjectURL(blob);
                                img.alt = `Product ${productId}`;
                                imageWrapper.appendChild(img);
                            }
                            
                            // Clean up the temporary URL
                            URL.revokeObjectURL(tempImg.src);
                        } else {
                            // For regular images, just show them
                            const img = document.createElement('img');
                            img.src = URL.createObjectURL(blob);
                            img.alt = `Product ${productId}`;
                            imageWrapper.appendChild(img);
                        }

                        imageContainer.appendChild(imageWrapper);
                    }
                } catch (error) {
                    console.error(`Error loading image ${url}:`, error);
                }
            }

            if (imageContainer.children.length === 0) {
                errorDiv.textContent = 'No images found for this product ID';
            }
        }

        function blobToDataUrl(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function adjustImageHue(img, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            for (let i = 0; i < data.length; i += 4) {
                if (data[i] < 250 || data[i + 1] < 250 || data[i + 2] < 250) {
                    data[i] = r;
                    data[i + 1] = g;
                    data[i + 2] = b;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            img.src = canvas.toDataURL();
        }

        async function isBlackAndWhite(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let blackPixels = 0;
            let whitePixels = 0;
            let totalPixels = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Check if pixel is black (all channels close to 0)
                if (r < 50 && g < 50 && b < 50) {
                    blackPixels++;
                }
                // Check if pixel is white (all channels close to 255)
                else if (r > 200 && g > 200 && b > 200) {
                    whitePixels++;
                }
                totalPixels++;
            }
            
            const blackPercentage = (blackPixels / totalPixels) * 100;
            const whitePercentage = (whitePixels / totalPixels) * 100;
            
            // Consider it black and white if more than 90% of pixels are either black or white
            return (blackPercentage + whitePercentage) > 90;
        }

        async function convertToSVG(img, originalWidth, originalHeight) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = originalWidth;
                canvas.height = originalHeight;
                
                ctx.drawImage(img, 0, 0);
                
                // Convert to black and white
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const gray = (r + g + b) / 3;
                    const threshold = 128;
                    
                    data[i] = data[i + 1] = data[i + 2] = gray < threshold ? 0 : 255;
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // Get the image data as a data URL
                const dataUrl = canvas.toDataURL('image/png');
                
                // Set Potrace parameters
                Potrace.setParameter({
                    turdsize: 25, // Minimum area of a path
                    alphamax: 0.8, // Maximum angle for a corner
                    optcurve: true, // Optimize curves
                    opttolerance: 0.2, // Curve optimization tolerance
                    threshold: 128 // Black/white threshold
                });
                
                // Load the image and process it
                Potrace.loadImageFromUrl(dataUrl);
                
                // Process the image and get SVG
                Potrace.process(function() {
                    // Get SVG at original size
                    const svg = Potrace.getSVG(1); // Use scale of 1 for original size
                    resolve(svg);
                });
            });
        }

        function tintSVG(svg, color) {
            if (!svg) return;
            
            // Get the path element
            const path = svg.querySelector('path');
            if (!path) return;
            
            // Update the fill color
            path.setAttribute('fill', color);
        }

        function createObjectDetectionControls(originalImage, svgContainer, originalWidth, originalHeight, productId) {
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'object-detection-controls';
            
            // Create toggle button for parameters
            const toggleButton = document.createElement('button');
            toggleButton.className = 'detection-toggle';
            toggleButton.innerHTML = `
                <span>Detection Parameters</span>
                <span class="detection-toggle-icon">▼</span>
            `;
            
            // Create collapsible parameters container
            const paramsContainer = document.createElement('div');
            paramsContainer.className = 'detection-params';
            
            // Create controls
            const controlRow1 = document.createElement('div');
            controlRow1.className = 'control-row';
            
            // Minimum object size control
            const minSizeGroup = document.createElement('div');
            minSizeGroup.className = 'control-group';
            
            const minSizeLabel = document.createElement('label');
            minSizeLabel.textContent = 'Min Object Size:';
            
            const minSizeInput = document.createElement('input');
            minSizeInput.type = 'range';
            minSizeInput.className = 'range-input';
            minSizeInput.min = '100';
            minSizeInput.max = '5000';
            minSizeInput.value = '500';
            minSizeInput.id = `minSize-${productId}`;
            
            const minSizeValue = document.createElement('span');
            minSizeValue.className = 'range-value';
            minSizeValue.textContent = minSizeInput.value;
            
            minSizeInput.addEventListener('input', () => {
                minSizeValue.textContent = minSizeInput.value;
            });
            
            minSizeGroup.appendChild(minSizeLabel);
            minSizeGroup.appendChild(minSizeInput);
            minSizeGroup.appendChild(minSizeValue);
            
            // Gap tolerance control
            const gapGroup = document.createElement('div');
            gapGroup.className = 'control-group';
            
            const gapLabel = document.createElement('label');
            gapLabel.textContent = 'Gap Tolerance:';
            
            const gapInput = document.createElement('input');
            gapInput.type = 'range';
            gapInput.className = 'range-input';
            gapInput.min = '1';
            gapInput.max = '40';
            gapInput.value = '20';
            gapInput.id = `gapTolerance-${productId}`;
            
            const gapValue = document.createElement('span');
            gapValue.className = 'range-value';
            gapValue.textContent = gapInput.value;
            
            gapInput.addEventListener('input', () => {
                gapValue.textContent = gapInput.value;
            });
            
            gapGroup.appendChild(gapLabel);
            gapGroup.appendChild(gapInput);
            gapGroup.appendChild(gapValue);
            
            controlRow1.appendChild(minSizeGroup);
            controlRow1.appendChild(gapGroup);
            
            // Add controls to parameters container
            paramsContainer.appendChild(controlRow1);
            
            // Create buttons container
            const buttonsContainer = document.createElement('div');
            buttonsContainer.style.display = 'flex';
            buttonsContainer.style.gap = '0.5rem';
            buttonsContainer.style.marginTop = '0.5rem';
            buttonsContainer.style.flexWrap = 'wrap';
            
            // Refresh objects button (initially hidden)
            const refreshButton = document.createElement('button');
            refreshButton.className = 'detect-button';
            refreshButton.textContent = 'Refresh Objects';
            refreshButton.style.display = 'none';
            refreshButton.id = `refreshButton-${productId}`;
            refreshButton.onclick = () => detectAndShowObjects(originalImage, svgContainer, originalWidth, originalHeight, productId);
            
            // Show/Hide borders toggle
            const toggleBordersButton = document.createElement('button');
            toggleBordersButton.className = 'detect-button';
            toggleBordersButton.textContent = 'Hide Borders';
            toggleBordersButton.style.backgroundColor = '#6b7280';
            toggleBordersButton.style.display = 'none'; // Initially hidden until objects are detected
            toggleBordersButton.id = `toggleBorders-${productId}`;
            toggleBordersButton.onclick = () => toggleObjectBorders(svgContainer, toggleBordersButton);
            
            buttonsContainer.appendChild(refreshButton);
            buttonsContainer.appendChild(toggleBordersButton);
            
            // Track parameter changes
            let lastMinSize = minSizeInput.value;
            let lastGapTolerance = gapInput.value;
            
            function checkParameterChanges() {
                const currentMinSize = minSizeInput.value;
                const currentGapTolerance = gapInput.value;
                
                if (currentMinSize !== lastMinSize || currentGapTolerance !== lastGapTolerance) {
                    refreshButton.style.display = 'inline-block';
                } else {
                    refreshButton.style.display = 'none';
                }
            }
            
            function updateLastParameters() {
                lastMinSize = minSizeInput.value;
                lastGapTolerance = gapInput.value;
                refreshButton.style.display = 'none';
            }
            
            // Update parameter change listeners
            minSizeInput.addEventListener('input', () => {
                minSizeValue.textContent = minSizeInput.value;
                checkParameterChanges();
            });
            
            gapInput.addEventListener('input', () => {
                gapValue.textContent = gapInput.value;
                checkParameterChanges();
            });
            
            // Store functions for external access
            svgContainer.updateLastParameters = updateLastParameters;
            svgContainer.showToggleBorders = () => {
                toggleBordersButton.style.display = 'inline-block';
            };
            
            
            // Toggle functionality
            toggleButton.addEventListener('click', () => {
                const isExpanded = paramsContainer.classList.contains('expanded');
                
                if (isExpanded) {
                    paramsContainer.classList.remove('expanded');
                    toggleButton.classList.remove('expanded');
                } else {
                    paramsContainer.classList.add('expanded');
                    toggleButton.classList.add('expanded');
                }
            });
            
            // Info area
            const infoDiv = document.createElement('div');
            infoDiv.className = 'object-count-info';
            infoDiv.id = `objectInfo-${productId}`;
            infoDiv.textContent = 'Auto-detecting objects in the image...';
            
            // Info about processing time
            const infoText = document.createElement('div');
            infoText.className = 'detection-warning';
            infoText.innerHTML = 'ℹ️ <strong>Auto-Detection:</strong> Objects are automatically detected when the image is converted. Processing typically takes 10-30 seconds in the background.';
            infoText.style.fontSize = '0.8rem';
            infoText.style.color = '#374151';
            infoText.style.textAlign = 'center';
            infoText.style.padding = '0.5rem';
            infoText.style.backgroundColor = '#f0f9ff';
            infoText.style.border = '1px solid #bae6fd';
            infoText.style.borderRadius = 'var(--border-radius)';
            infoText.style.marginTop = '0.5rem';
            
            // Assemble the structure
            controlsDiv.appendChild(toggleButton);
            controlsDiv.appendChild(paramsContainer);
            controlsDiv.appendChild(buttonsContainer);
            controlsDiv.appendChild(infoDiv);
            controlsDiv.appendChild(infoText);
            
            // Auto-start object detection
            setTimeout(() => {
                detectAndShowObjects(originalImage, svgContainer, originalWidth, originalHeight, productId);
            }, 500);
            
            return controlsDiv;
        }

        function detectAndShowObjects(originalImage, svgContainer, originalWidth, originalHeight, productId) {
            // Clear any existing overlays
            const existingOverlays = svgContainer.querySelectorAll('.object-overlay');
            existingOverlays.forEach(overlay => overlay.remove());
            
            // Get UI elements - use the refresh button instead of old detect button
            const refreshButton = document.getElementById(`refreshButton-${productId}`);
            const toggleBordersButton = document.getElementById(`toggleBorders-${productId}`);
            const infoDiv = document.getElementById(`objectInfo-${productId}`);
            
            // Set loading state
            if (refreshButton) {
                refreshButton.textContent = 'Detecting...';
                refreshButton.disabled = true;
                refreshButton.style.backgroundColor = '#9ca3af';
                refreshButton.style.cursor = 'not-allowed';
            }
            
            if (infoDiv) {
                infoDiv.textContent = 'Analyzing image for objects...';
                infoDiv.style.color = '#059669';
            }
            
            // Get parameters
            const minSize = parseInt(document.getElementById(`minSize-${productId}`).value);
            const gapTolerance = parseInt(document.getElementById(`gapTolerance-${productId}`).value);
            
            // Start async processing (no setTimeout needed since we're chunking)
            findConnectedComponents(originalImage, minSize, gapTolerance)
                .then(objects => {
                    // Update info
                    if (objects.length > 0) {
                        infoDiv.textContent = `Found ${objects.length} objects. Click on any highlighted area to extract it.`;
                        infoDiv.style.color = '#059669';
                        
                        // Show the toggle borders button when objects are found
                        if (toggleBordersButton) {
                            toggleBordersButton.style.display = 'inline-block';
                        }
                    } else {
                        infoDiv.textContent = 'No objects found. Try adjusting the parameters.';
                        infoDiv.style.color = '#dc2626';
                        
                        // Hide the toggle borders button when no objects
                        if (toggleBordersButton) {
                            toggleBordersButton.style.display = 'none';
                        }
                    }
                    
                    // Create clickable overlays for each object
                    objects.forEach((obj, index) => {
                        const overlay = document.createElement('div');
                        overlay.className = 'object-overlay detected';
                        
                        // Store object data for resize updates
                        overlay.dataset.objectBounds = JSON.stringify(obj.bounds);
                        overlay.dataset.originalWidth = originalWidth;
                        overlay.dataset.originalHeight = originalHeight;
                        overlay.dataset.objectIndex = index;
                        
                        // Calculate initial position
                        updateOverlayPosition(overlay, svgContainer);
                        
                        overlay.title = `Object ${index + 1} (${obj.pixelCount} pixels)`;
                        
                        overlay.addEventListener('click', (e) => {
                            e.stopPropagation();
                            extractObject(obj, originalImage, originalWidth, originalHeight, productId, index + 1);
                            overlay.style.display = 'none';
                        });
                        
                        svgContainer.appendChild(overlay);
                    });
                    
                    // Add resize listener for this container if not already added
                    if (!svgContainer.dataset.resizeListenerAdded) {
                        svgContainer.dataset.resizeListenerAdded = 'true';
                        
                        const resizeObserver = new ResizeObserver(() => {
                            updateAllOverlayPositions(svgContainer);
                        });
                        resizeObserver.observe(svgContainer);
                        
                        // Also listen for window resize as a backup
                        window.addEventListener('resize', () => {
                            setTimeout(() => updateAllOverlayPositions(svgContainer), 50);
                        });
                    }
                    
                    // Update parameter tracking to hide refresh button
                    if (svgContainer.updateLastParameters) {
                        svgContainer.updateLastParameters();
                    }
                    
                    // Sync toggle borders button state - after refresh, borders are visible so button should say "Hide Borders"
                    if (toggleBordersButton && objects.length > 0) {
                        toggleBordersButton.textContent = 'Hide Borders';
                    }
                })
                .catch(error => {
                    console.error('Error during object detection:', error);
                    infoDiv.textContent = 'Error occurred during object detection. Please try again.';
                    infoDiv.style.color = '#dc2626';
                })
                .finally(() => {
                    // Restore button state
                    if (refreshButton) {
                        refreshButton.textContent = 'Refresh Objects';
                        refreshButton.disabled = false;
                        refreshButton.style.backgroundColor = '#059669';
                        refreshButton.style.cursor = 'pointer';
                    }
                });
        }

        function updateOverlayPosition(overlay, svgContainer) {
            const bounds = JSON.parse(overlay.dataset.objectBounds);
            const originalWidth = parseInt(overlay.dataset.originalWidth);
            const originalHeight = parseInt(overlay.dataset.originalHeight);
            
            // Calculate position relative to current SVG container size
            const containerRect = svgContainer.getBoundingClientRect();
            const scaleX = containerRect.width / originalWidth;
            const scaleY = containerRect.height / originalHeight;
            
            overlay.style.left = `${bounds.left * scaleX}px`;
            overlay.style.top = `${bounds.top * scaleY}px`;
            overlay.style.width = `${bounds.width * scaleX}px`;
            overlay.style.height = `${bounds.height * scaleY}px`;
        }

        function updateAllOverlayPositions(svgContainer) {
            const overlays = svgContainer.querySelectorAll('.object-overlay.detected');
            overlays.forEach(overlay => {
                if (overlay.style.display !== 'none') {
                    updateOverlayPosition(overlay, svgContainer);
                }
            });
        }

        function toggleObjectBorders(svgContainer, toggleButton) {
            const overlays = svgContainer.querySelectorAll('.object-overlay.detected');
            const isCurrentlyVisible = overlays.length > 0 && overlays[0].style.visibility !== 'hidden';
            
            overlays.forEach(overlay => {
                if (isCurrentlyVisible) {
                    overlay.style.visibility = 'hidden';
                    toggleButton.textContent = 'Show Borders';
                } else {
                    overlay.style.visibility = 'visible';
                    toggleButton.textContent = 'Hide Borders';
                }
            });
        }

        function findConnectedComponents(image, minSize, gapTolerance) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = image.naturalWidth;
                canvas.height = image.naturalHeight;
                ctx.drawImage(image, 0, 0);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;
                
                // Convert to binary array (true for black pixels) - optimized with larger chunks and Uint8Array
                const binary = new Uint8Array(width * height);
                
                // Process binary conversion in larger chunks for better performance
                let binaryIndex = 0;
                function processBinaryChunk() {
                    const chunkSize = 50000; // Increased from 10k to 50k pixels per chunk
                    const endIndex = Math.min(binaryIndex + chunkSize, data.length);
                    
                    // Optimized binary conversion with bitwise operations
                    for (let i = binaryIndex; i < endIndex; i += 4) {
                        const gray = (data[i] + data[i + 1] + data[i + 2]) * 0.333; // Faster than division
                        binary[i >> 2] = gray < 128 ? 1 : 0; // Bitwise shift instead of division
                    }
                    
                    binaryIndex = endIndex;
                    
                    if (binaryIndex < data.length) {
                        requestAnimationFrame(processBinaryChunk);
                    } else {
                        processMorphology();
                    }
                }
                
                function processMorphology() {
                    if (gapTolerance <= 1) {
                        findComponents();
                        return;
                    }
                    
                    let iter = 0;
                    function dilateIteration() {
                        if (iter >= gapTolerance) {
                            findComponents();
                            return;
                        }
                        
                        // Use in-place dilation with temp array for better memory efficiency
                        const temp = new Uint8Array(width * height);
                        let processed = 0;
                        const chunkSize = 5000; // Increased from 1k to 5k pixels per chunk
                        
                        function processDilateChunk() {
                            const endRow = Math.min(processed + chunkSize, height - 1);
                            
                            for (let y = Math.max(processed, 1); y < endRow; y++) {
                                const rowOffset = y * width;
                                for (let x = 1; x < width - 1; x++) {
                                    const idx = rowOffset + x;
                                    if (!binary[idx]) {
                                        // Optimized neighbor check - unrolled loop for speed
                                        if (binary[idx - width - 1] || binary[idx - width] || binary[idx - width + 1] ||
                                            binary[idx - 1] || binary[idx + 1] ||
                                            binary[idx + width - 1] || binary[idx + width] || binary[idx + width + 1]) {
                                            temp[idx] = 1;
                                        }
                                    } else {
                                        temp[idx] = 1;
                                    }
                                }
                            }
                            
                            processed = endRow;
                            
                            if (processed < height - 1) {
                                requestAnimationFrame(processDilateChunk);
                            } else {
                                binary.set(temp); // Fast array copy
                                iter++;
                                requestAnimationFrame(dilateIteration);
                            }
                        }
                        
                        processDilateChunk();
                    }
                    
                    dilateIteration();
                }
                
                function findComponents() {
                    const visited = new Uint8Array(width * height);
                    const components = [];
                    let currentY = 0;
                    
                    function processComponentChunk() {
                        const chunkSize = 200; // Increased from 50 to 200 rows per chunk
                        const endY = Math.min(currentY + chunkSize, height);
                        
                        for (let y = currentY; y < endY; y++) {
                            const rowOffset = y * width;
                            for (let x = 0; x < width; x++) {
                                const idx = rowOffset + x;
                                if (binary[idx] && !visited[idx]) {
                                    const component = floodFillOptimized(x, y, binary, visited, width, height);
                                    if (component.pixelCount >= minSize) {
                                        // Calculate final bounds
                                        component.bounds.width = component.bounds.right - component.bounds.left + 1;
                                        component.bounds.height = component.bounds.bottom - component.bounds.top + 1;
                                        
                                        // Add lazy pixel reconstruction for extraction
                                        component.getPixels = () => getPixelsFromBounds(component.bounds, binary, width);
                                        
                                        components.push(component);
                                    }
                                }
                            }
                        }
                        
                        currentY = endY;
                        
                        if (currentY < height) {
                            requestAnimationFrame(processComponentChunk);
                        } else {
                            resolve(components);
                        }
                    }
                    
                    processComponentChunk();
                }
                
                processBinaryChunk();
            });
        }

        function floodFillOptimized(startX, startY, binary, visited, width, height) {
            // Use array for stack instead of pushing objects for better performance
            const stack = new Array(width * height * 2); // Pre-allocate maximum possible size
            let stackTop = 0;
            stack[stackTop++] = startX;
            stack[stackTop++] = startY;
            
            const component = {
                pixelCount: 0,
                bounds: { left: startX, top: startY, right: startX, bottom: startY }
            };
            
            while (stackTop > 0) {
                const y = stack[--stackTop];
                const x = stack[--stackTop];
                const idx = y * width + x;
                
                if (x < 0 || x >= width || y < 0 || y >= height || visited[idx] || !binary[idx]) {
                    continue;
                }
                
                visited[idx] = 1;
                component.pixelCount++;
                
                // Update bounds with bitwise operations for slight performance gain
                if (x < component.bounds.left) component.bounds.left = x;
                if (x > component.bounds.right) component.bounds.right = x;
                if (y < component.bounds.top) component.bounds.top = y;
                if (y > component.bounds.bottom) component.bounds.bottom = y;
                
                // Add 4-connected neighbors - unrolled for better performance
                if (x + 1 < width) {
                    stack[stackTop++] = x + 1;
                    stack[stackTop++] = y;
                }
                if (x - 1 >= 0) {
                    stack[stackTop++] = x - 1;
                    stack[stackTop++] = y;
                }
                if (y + 1 < height) {
                    stack[stackTop++] = x;
                    stack[stackTop++] = y + 1;
                }
                if (y - 1 >= 0) {
                    stack[stackTop++] = x;
                    stack[stackTop++] = y - 1;
                }
            }
            
            return component;
        }

        // Helper function to reconstruct pixel coordinates from binary data for extraction
        function getPixelsFromBounds(bounds, binary, width) {
            const pixels = [];
            for (let y = bounds.top; y <= bounds.bottom; y++) {
                const rowOffset = y * width;
                for (let x = bounds.left; x <= bounds.right; x++) {
                    const idx = rowOffset + x;
                    if (binary[idx]) {
                        pixels.push({ x, y });
                    }
                }
            }
            return pixels;
        }

        function extractObject(objectData, originalImage, originalWidth, originalHeight, productId, objectNumber) {
            // Show loading feedback
            const infoDiv = document.getElementById(`objectInfo-${productId}`);
            if (infoDiv) {
                infoDiv.textContent = `Extracting Object ${objectNumber}...`;
                infoDiv.style.color = '#059669';
            }
            
            // Use setTimeout to allow UI to update
            setTimeout(() => {
                try {
                    // Create a new canvas with just this object
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    const bounds = objectData.bounds;
                    const padding = 20; // Add some padding around the object
                    
                    canvas.width = bounds.width + (padding * 2);
                    canvas.height = bounds.height + (padding * 2);
                    
                    // Fill with white
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Get original image data
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = originalWidth;
                    tempCanvas.height = originalHeight;
                    tempCtx.drawImage(originalImage, 0, 0);
                    const originalData = tempCtx.getImageData(0, 0, originalWidth, originalHeight);
                    
                    // Create new image data for just this object
                    const newImageData = ctx.createImageData(canvas.width, canvas.height);
                    const newData = newImageData.data;
                    
                    // Fill new canvas with white
                    for (let i = 0; i < newData.length; i += 4) {
                        newData[i] = 255;     // R
                        newData[i + 1] = 255; // G  
                        newData[i + 2] = 255; // B
                        newData[i + 3] = 255; // A
                    }
                    
                    // Copy only the pixels belonging to this object
                    objectData.getPixels().forEach(pixel => {
                        const sourceIdx = (pixel.y * originalWidth + pixel.x) * 4;
                        const targetX = pixel.x - bounds.left + padding;
                        const targetY = pixel.y - bounds.top + padding;
                        const targetIdx = (targetY * canvas.width + targetX) * 4;
                        
                        if (targetIdx >= 0 && targetIdx < newData.length) {
                            newData[targetIdx] = originalData.data[sourceIdx];         // R
                            newData[targetIdx + 1] = originalData.data[sourceIdx + 1]; // G
                            newData[targetIdx + 2] = originalData.data[sourceIdx + 2]; // B
                            newData[targetIdx + 3] = 255;                              // A
                        }
                    });
                    
                    ctx.putImageData(newImageData, 0, 0);
                    
                    // Convert to image and then to SVG
                    const extractedImage = new Image();
                    extractedImage.onload = async () => {
                        try {
                            const svg = await convertToSVG(extractedImage, canvas.width, canvas.height);
                            createExtractedObjectCard(svg, canvas.width, canvas.height, productId, objectNumber);
                            
                            // Restore info message
                            if (infoDiv) {
                                const objectsContainer = document.getElementById(`objects-${productId}`);
                                const objectCount = objectsContainer ? objectsContainer.children.length : 0;
                                const remainingOverlays = document.querySelectorAll('.object-overlay.detected').length;
                                if (remainingOverlays > 0) {
                                    infoDiv.textContent = `Object ${objectNumber} extracted! Click on remaining highlighted areas to extract more objects.`;
                                } else {
                                    infoDiv.textContent = `All visible objects have been extracted. You can adjust parameters and detect again to find different objects.`;
                                }
                            }
                        } catch (error) {
                            console.error('Error converting object to SVG:', error);
                            if (infoDiv) {
                                infoDiv.textContent = `Error extracting Object ${objectNumber}. Please try again.`;
                                infoDiv.style.color = '#dc2626';
                            }
                        }
                    };
                    extractedImage.src = canvas.toDataURL();
                } catch (error) {
                    console.error('Error during object extraction:', error);
                    if (infoDiv) {
                        infoDiv.textContent = `Error extracting Object ${objectNumber}. Please try again.`;
                        infoDiv.style.color = '#dc2626';
                    }
                }
            }, 50);
        }

        function createExtractedObjectCard(svgString, width, height, productId, objectNumber) {
            const objectsContainer = document.getElementById(`objects-${productId}`);
            if (!objectsContainer) return;
            
            // Show the objects header if this is the first object
            const objectsHeader = document.getElementById(`objectsHeader-${productId}`);
            if (objectsHeader && objectsContainer.children.length === 0) {
                objectsHeader.style.display = 'block';
            }
            
            // Create the object card
            const objectCard = document.createElement('div');
            objectCard.className = 'svg-object-card';
            
            // Create preview container
            const preview = document.createElement('div');
            preview.className = 'svg-object-preview';
            
            // Create SVG element
            const svgContainer = document.createElement('div');
            svgContainer.innerHTML = svgString;
            const svg = svgContainer.querySelector('svg');
            if (svg) {
                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
            }
            preview.appendChild(svg);
            
            // Create controls container
            const controls = document.createElement('div');
            controls.className = 'object-controls';
            
            // Create header
            const header = document.createElement('div');
            header.className = 'object-header';
            
            const title = document.createElement('span');
            title.textContent = `Object ${objectNumber}`;
            
            const actions = document.createElement('div');
            actions.className = 'object-actions';
            
            const removeButton = document.createElement('button');
            removeButton.className = 'remove-object';
            removeButton.textContent = 'Remove';
            removeButton.onclick = () => objectCard.remove();
            
            const downloadButton = document.createElement('button');
            downloadButton.textContent = 'Download';
            downloadButton.onclick = () => downloadObjectSVG(svg, productId, width, height);
            
            actions.appendChild(downloadButton);
            actions.appendChild(removeButton);
            
            header.appendChild(title);
            header.appendChild(actions);
            
            // Create color controls for the object
            const colorControl = createObjectColorControls(svg);
            
            controls.appendChild(header);
            controls.appendChild(colorControl);
            
            objectCard.appendChild(preview);
            objectCard.appendChild(controls);
            
            objectsContainer.appendChild(objectCard);
            
            // Scroll to the new object card
            objectCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function createObjectColorControls(svg) {
            const colorControl = document.createElement('div');
            colorControl.className = 'color-control';
            
            // Create color inputs container
            const colorInputs = document.createElement('div');
            colorInputs.className = 'color-inputs';
            
            const colorPicker = document.createElement('input');
            colorPicker.type = 'color';
            colorPicker.className = 'color-picker';
            colorPicker.value = '#000000';
            
            const hexInput = document.createElement('input');
            hexInput.type = 'text';
            hexInput.className = 'hex-input';
            hexInput.value = '#000000';
            hexInput.placeholder = '#000000';

            // Add palette selector
            const paletteSelector = document.createElement('select');
            paletteSelector.className = 'palette-selector';
            
            // Add color palettes (reusing the same palettes from main controls)
            const colorPalettes = {
                "2025-2027 In Colors": {
                    "Strawberry Slush": "#f26b73",
                    "Timid Tiger": "#f68e4f",
                    "Darling Duckling": "#f0d34f",
                    "Cloud Cover": "#b4c5c0",
                    "Secret Sea": "#334249"
                },
                "2024-2026 In Colors": {
                    "Pretty in Pink": "#f8abb6",
                    "Peach Pie": "#fab474",
                    "Shy Shamrock": "#49bc8f",
                    "Summer Splash": "#63c4b1",
                    "Petunia Pop": "#d37eb4"
                },
                "Basics": {
                    "Basic Beige": "#e3dbc5",
                    "Very Vanilla": "#fff7e1",
                    "Basic White": "#ffffff",
                    "White Willow": "#ffffff",
                    "Basic Black": "#000000",
                    "Bronze & Ivory": "#a97448",
                    "Crumb Cake": "#c8ad8c"
                },
                "Subtles": {
                    "Petal Pink": "#fcd1bb",
                    "Calypso Coral": "#f47e63",
                    "Lemon Lolly": "#fff8a2",
                    "Soft Sea Foam": "#e6f1d2",
                    "Lost Lagoon": "#7baaa1",
                    "Pool Party": "#a9dbd6",
                    "Balmy Blue": "#a0d6ea",
                    "Highland Heather": "#ad95c6",
                    "Fresh Freesia": "#e6b7d6",
                    "Bubble Bath": "#fad5e6"
                },
                "Brights": {
                    "Poppy Parade": "#ed193a",
                    "Melon Mambo": "#e94d87",
                    "Flirty Flamingo": "#f5928b",
                    "Pumpkin Pie": "#f89433",
                    "Daffodil Delight": "#ffdc67",
                    "Lemon Lime Twist": "#dee568",
                    "Granny Apple Green": "#a3c149",
                    "Coastal Cabana": "#90d2be",
                    "Azure Afternoon": "#27a0d6",
                    "Berry Burst": "#b74985"
                },
                "Regals": {
                    "Cherry Cobbler": "#a10637",
                    "Real Red": "#c52342",
                    "Cajun Craze": "#c0492d",
                    "Crushed Curry": "#f8bd16",
                    "Old Olive": "#98a04d",
                    "Garden Green": "#4d8b56",
                    "Shaded Spruce": "#00815b",
                    "Pretty Peacock": "#006f71",
                    "Blueberry Bushel": "#0d5993",
                    "Gorgeous Grape": "#855da4"
                },
                "Neutrals": {
                    "Mossy Meadow": "#656739",
                    "Misty Moonlight": "#58728e",
                    "Night of Navy": "#213e6d",
                    "Blackberry Bliss": "#582752",
                    "Early Espresso": "#63412c",
                    "Pecan Pie": "#a97448",
                    "Crumb Cake": "#c8ad8c",
                    "Gray Granite": "#b3aba1",
                    "Smoky Slate": "#bdbdbe",
                    "Basic Gray": "#767e85"
                }
            };

            // Add options to palette selector
            Object.keys(colorPalettes).forEach(paletteName => {
                const option = document.createElement('option');
                option.value = paletteName;
                option.textContent = paletteName;
                paletteSelector.appendChild(option);
            });

            // Create color palette container
            const colorPalette = document.createElement('div');
            colorPalette.className = 'color-palette';

            // Function to update color palette
            function updateColorPalette(paletteName) {
                colorPalette.innerHTML = '';
                const colors = colorPalettes[paletteName];
                
                Object.entries(colors).forEach(([name, hex]) => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = hex;
                    swatch.title = name;
                    
                    swatch.addEventListener('click', () => {
                        // Remove active class from all swatches
                        colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                        // Add active class to clicked swatch
                        swatch.classList.add('active');
                        
                        // Update color picker and hex input
                        colorPicker.value = hex;
                        hexInput.value = hex;
                        tintSVG(svg, hex);
                    });
                    
                    colorPalette.appendChild(swatch);
                });
            }

            // Initial palette update
            updateColorPalette(paletteSelector.value);

            // Update palette when selection changes
            paletteSelector.addEventListener('change', (e) => {
                updateColorPalette(e.target.value);
            });
            
            // Sync color picker and hex input
            colorPicker.addEventListener('input', (e) => {
                const color = e.target.value;
                hexInput.value = color;
                tintSVG(svg, color);
                // Remove active class from all swatches
                colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            });
            
            hexInput.addEventListener('input', (e) => {
                let color = e.target.value;
                // Add # if missing
                if (color.charAt(0) !== '#') {
                    color = '#' + color;
                }
                // Validate hex color
                if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                    colorPicker.value = color;
                    tintSVG(svg, color);
                    // Remove active class from all swatches
                    colorPalette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                }
            });
            
            // Assemble the structure
            colorInputs.appendChild(colorPicker);
            colorInputs.appendChild(hexInput);
            
            colorControl.appendChild(colorInputs);
            colorControl.appendChild(paletteSelector);
            
            // Create a container for the palette
            const paletteContainer = document.createElement('div');
            paletteContainer.appendChild(colorPalette);
            
            const fullControl = document.createElement('div');
            fullControl.appendChild(colorControl);
            fullControl.appendChild(paletteContainer);
            
            return fullControl;
        }

        function downloadObjectSVG(svg, productId, originalWidth, originalHeight) {
            if (!svg) return;
            
            // Create a copy of the SVG to modify
            const svgCopy = svg.cloneNode(true);
            
            // Set the viewBox to match original dimensions
            svgCopy.setAttribute('viewBox', `0 0 ${originalWidth} ${originalHeight}`);
            
            // Set width and height to match original dimensions
            svgCopy.setAttribute('width', originalWidth);
            svgCopy.setAttribute('height', originalHeight);
            
            // Create a blob from the SVG
            const svgData = new XMLSerializer().serializeToString(svgCopy);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            
            // Create a download link
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `stampinup_${productId}_object_${Date.now()}.svg`;
            
            // Trigger the download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function downloadSVG(svg, productId, originalWidth, originalHeight) {
            if (!svg) return;
            
            // Create a copy of the SVG to modify
            const svgCopy = svg.cloneNode(true);
            
            // Set the viewBox to match original dimensions
            svgCopy.setAttribute('viewBox', `0 0 ${originalWidth} ${originalHeight}`);
            
            // Set width and height to match original dimensions
            svgCopy.setAttribute('width', originalWidth);
            svgCopy.setAttribute('height', originalHeight);
            
            // Create a blob from the SVG
            const svgData = new XMLSerializer().serializeToString(svgCopy);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            
            // Create a download link
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `stampinup_${productId}.svg`;
            
            // Trigger the download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html> 